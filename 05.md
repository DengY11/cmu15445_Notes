# CMU15445 05
## 数据库负载类型(database workloads)
### OLTP:在线事务处理(Online Transaction Processing)
- **特征**：OLTP负载以**快速**、**短时操**作为特点，具有**重复性**操作和**简单**的查询，每次操作仅针对**单个实体**。通常，OLTP负载的**写操作多于读操作**，每次读取或更新的数据量很小。
- **示例**：Amazon的在线商店，用户可以将商品添加到购物车并进行购买，但这些操作只影响用户的账户。

### OLAP: 在线分析处理（Online Analytical Processing）
- **特征**：OLAP负载以**长时间运行**、**复杂**的查询和**大范围的数据**读取为特点。OLAP工作负载通常分析和推导现有数据以产生新数据，数据主要来自OLTP收集的内容。
- **示例**：Amazon计算在匹兹堡一个下雨天购买最多的商品。

### HTAP: 混合事务与分析处理（Hybrid Transaction + Analytical Processing）
- **特征**：HTAP是一种新的工作负载类型，最近变得流行。HTAP同时处理OLTP和OLAP工作负载，两者在同一数据库上共存。

## 存储模型
### N-Ary Storage Model (NSM)
**概述**：
- 即**行储存**，在NSM中，数据库管理系统（DBMS）将单个元组的**所有属性**连续存储在一个页面中。这种方法适合**OLTP**工作负载，因为它们通常是**插入密集型**的，并且事务往往只操作单个实体。
<img src="./05 pictrue/1.png" alt="图片描述" width="400" height="350">

- **优点**：
  - 插入、更新和删除操作速度快。
  - 对于需要整个元组的查询效果很好。
- **缺点**：
<img src="./05 pictrue/2.png" alt="图片描述" width="400" height="350">
  - 大量的**无用I/O**，对于扫描大部分表格和/或部分属性的查询效率低下。
### Decomposition Storage Model (DSM)
**概述**
- 即**列储存**，在DSM中，DBMS将所有元组的**单个属性（列）**连续存储在一个数据块中。这种模型适合OLAP工作负载，因为这些查询通常是**只读**的，需要对**部分属性**进行大规模扫描。

<img src="./05 pictrue/3.png" alt="图片描述" width="300" height="350">

- **优点**：
  - 减少I/O浪费，因为DBMS只读取查询所需的数据。
  - 由于数据局部性和缓存数据重用，查询处理速度更快。
  - 数据压缩效果更好。
![](./05%20pictrue/4.png)
- **缺点**：
  - 对于点查询、插入、更新和删除操作速度慢，因为需要进行元组的分拆和重组。
#### DSM重新组合元组的方法：
- **固定长度偏移（Fixed-Length Offsets）**：这是最常用的方法。每个列中的值在相同的**偏移处**(offset)属于同一个元组，
（*也就是说，某一列中的第n个值与另一列中的第n个值属于同一个元组*），
因此每个值的长度必须相同来达到每个列在物理存储中具有相同的偏移量。
- **嵌入元组ID（Embedded Tuple IDs）**：对于每个列中的**属性**，DBMS会存储一个**元组ID**（如主键），这些元组ID用来标识该值属于哪个元组。并存储一个映射以跳转到具有该ID的**每个属性**。这种方法存储开销大，因为需要为每个属性条目存储一个元组ID。

### Partition Attributes Across (PAX)
**概述**
- PAX是一种**混合存储模型**。在PAX模型中，数据库页面被划分为多个小的**行组（Row Groups）**，在每个行组内，数据按列进行**垂直分区**存储。这样做的目的是在保持行存储的空间局部性优势的同时，获得列存储的更快处理速度。
<img src="./05 pictrue/5.png" alt="图片描述" width="400" height="490">
- **优点**：
  - 将行水平分区为行组，每个行组内的属性垂直分区为列。每个行组类似于其子集的列存储(具体看下面例子)。

- 一个PAX文件有一个**全局头**，包含指向文件行组的**目录偏移**，每个行组有自己的头，包含其内容的**元数据**。

**例子**:
- 假设我们有一个包含四列的数据表：ID, Name, Age, Salary。在PAX模型中，一个页面可能会被分成两部分，每部分是一个行组。

  - 行组1：
    ~~~
    ID: 1, 2, 3
    Name: Alice, Bob, Charlie
    Age: 30, 25, 35
    Salary: 1000, 1500, 2000
    ~~~
  - 行组2：
    ~~~
    ID: 4, 5, 6
    Name: David, Eva, Frank
    Age: 40, 22, 28
    Salary: 2500, 3000, 1800
    ~~~
- 在每个行组内，数据按列存储，例如行组1中的ID列、Name列、Age列和Salary列分别连续存储。

## 数据库压缩(Database Compression)
### 压缩的重要性
- 压缩在基于磁盘的DBMS中广泛应用，因为**磁盘I/O**几乎总是主要瓶颈。压缩在只读分析工作负载的系统中尤其受欢迎。通过**预先压缩数据**，DBMS可以提取更多有用的元组，尽管这会带来更高的压缩和解压缩计算**开销**。

### 内存数据库（In-Memory DBMS）
- 内存数据库的情况更为复杂，因为它们**不需要**从磁盘中获取数据来执行查询。尽管内存(DRAM)比磁盘快，但压缩数据库可以减少**DRAM需求**和**处理量**。内存数据库需要在速度和压缩比之间取得平衡。压缩数据库减少了DRAM需求，并且可能在查询执行过程中降低CPU成本。

### 压缩的关键属性
如果数据集完全是**随机的比特(random bits)**，则无法进行压缩。然而，现实世界的数据集有一些适合压缩的**关键属性**：
- 属性值的**高度偏斜分布(highly skewed distributions)**（*eg*:**Zipfian distribution of the Brown Corpus**）。
- 同一元组中属性之间的**高度相关性(high correlation)**（*eg*:邮政编码到城市，订单日期到发货日期）。

基于这些属性，我们希望数据库压缩方案具有以下特性：
- **压缩后长度固定(produce fixed-length values)**：唯一的例外是存储在**独立池(separate pool)**中的可变长度数据。因为DBMS应该遵循字对齐并能够使用偏移量访问数据。
- **延迟解压缩**：允许DBMS在查询执行过程中尽可能推迟解压缩（**晚物化(later materialization)**）。
- **无损压缩**：因为用户不喜欢数据丢失。任何类型的有损压缩都必须在应用层面进行。
### 压缩粒度
我们希望压缩的数据类型极大地影响可以使用的压缩方案。有四种压缩粒度：

- **块级压缩（Block Level）**：压缩同一表的一个元组块。
- **元组级压缩（Tuple Level）**：压缩整个元组的内容（仅适用于NSM）。
- **属性级压缩（Attribute Level）**：压缩一个元组中的单个属性值。可以针对同一元组的多个属性进行压缩。
- **列级压缩（Columnar Level）**：压缩存储在多个元组中的一个或多个属性的多个值（仅适用于DSM）。这允许使用更复杂的压缩方案。
### 详细解释
- #### 1.块级压缩（Block Level）：
  - **概念**：对同一个表的一个块的多个元组进行压缩。
  - **优势**：可以显著减少I/O操作，因为一个压缩块可以包含多个元组。
  - **适用场景**：适用于磁盘存储，因为读取和写入操作通常是基于块的。
- #### 2.元组级压缩（Tuple Level）：
  - **概念**：对一个元组的整个内容进行压缩。
  - **优势**：在NSM（N-Ary Storage Model）中特别有效，因为每个元组的所有属性都被连续存储。
  - **适用场景**：适用于行存储模型（NSM），特别是当查询需要访问整个元组时。
- #### 3.属性级压缩（Attribute Level）：
  - **概念**：对一个元组中的单个属性值进行压缩。
  - **优势**：可以有针对性地对特定属性进行压缩，提高压缩效率。
  - **适用场景**：适用于需要部分属性的查询，或者某些属性值重复率高的情况。
- #### 4.列级压缩（Columnar Level）：
  - **概念**：对存储在多个元组中的一个或多个属性的多个值进行压缩。
  - **优势**：由于同一列的数据类型相同且相邻存储，压缩效率高，可以使用更复杂的压缩算法。
  - **适用场景**：适用于列存储模型（DSM），特别是分析查询需要扫描大量列数据时。

## Naive Compression（朴素压缩）
### 概述
朴素压缩是一种使用**通用**算法来压缩数据的方法。常见的压缩算法包括 gzip、LZO、LZ4、Snappy、Brotli、Oracle OZIP 和 Zstd。尽管有多种压缩算法可供选择，工程师通常会选择那些**压缩比低**但压缩/解压速度更**快**的算法。

#### MySQL InnoDB中的示例
- **工作方式**：在 MySQL InnoDB 中，数据库管理系统（DBMS）会压缩磁盘页面，将它们填充到 2KB 的幂次方大小(以符合内存对齐要求)，并将它们存储在**缓冲池**中。
- **读取/修改数据**：每次 DBMS 尝试读取或修改数据时，必须首先解压缩缓冲池中的压缩数据。这种方式限制了压缩方案的范围。
### 局限性
- **范围限制**：
  - 如果目标是将整个表压缩成**一个**巨大的块，使用朴素压缩方案是不可能的，因为每次访问都需要解压/压缩**整个表**。
  - 因此，MySQL 将表拆分成较**小**的块进行压缩，因为**压缩范围受限**。
- **缺乏数据语义感知**：
  - 这些朴素的压缩方案并不考虑数据的**高层**次含义或语义。压缩算法对数据的结构以及查询访问数据的方式一无所知。
  - 这**消除**了利用晚物化(late materialization)的机会，因为 DBMS **无法**确定何时可以延迟**解压缩**数据。
### 朴素压缩的优缺点
- **优点**
  - **快速**压缩/解压缩：选择低压缩比但速度快的算法，可以提高系统的响应速度。
  - **简单**实现：朴素压缩方案通常实现简单，不需要考虑数据的具体结构或查询模式。
- **缺点**
  - 解压缩开销：每次访问数据都需要解压缩，**增加**了计算**开销**。
  - 有限的压缩范围：无法将**整个**表作为一个块进行压缩，必须将表拆分成较小的块。
  - 缺乏语义感知：算法对数据的结构和查询模式一无所知，无法进行优化，如延迟解压缩。

*朴素的游程编码(run-length encoding)*
<img src="./05 pictrue/6.png" alt="图片描述" width="400" height="250">

*打包没有利用的bit位*
<img src="./05 pictrue/7.png" alt="图片描述" width="600" height="300">
此外还有**bitmap** 和 **delta encoding**等压缩方法
