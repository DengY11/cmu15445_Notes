# CMU15445
## 多版本并发控制 (Multi-Version Concurrency Control)

### 1. 隔离级别
这一部分已经在第17讲的笔记中提到。

### 2. 多版本并发控制 (MVCC)

<img src="./18 pictrue/1.png" alt="" width="600" height="350">

**多版本并发控制 (MVCC)** 是一个比并发控制协议更广泛的概念，涉及到数据库管理系统 (DBMS) 的设计和实现的各个方面。MVCC 是目前 DBMS 中最广泛使用的方案，几乎所有最近10年开发的新数据库系统都在使用它。甚至一些不支持多语句事务的系统（如 NoSQL）也采用了 MVCC。

在 MVCC 中，DBMS 为每个逻辑对象维护多个物理版本。当事务写入对象时，DBMS 会创建该对象的一个新版本；当事务读取对象时，它读取事务开始时存在的最新版本。

MVCC 的基本理念/优势在于：**写操作不会阻塞读操作，读操作也不会阻塞写操作**。这意味着一个事务可以修改对象，而其他事务可以同时读取旧版本的对象。不过，写入相同对象的多个事务仍然会发生写锁冲突，因为相关版本的锁仍然存在。

MVCC 的另一个优势是，**只读事务可以读取数据库的一个一致快照，而不需要使用任何锁**。此外，多版本的 DBMS 也能轻松支持**时间旅行查询**，即基于数据库某个时间点状态的查询（例如，查询数据库3小时前的状态）。

---
### 一个例子

假设我们有一个数据库表 `employees`，存储员工信息，包括员工的 `id` 和 `salary`，并且有两个并发运行的事务 \( T_1 \) 和 \( T_2 \)：

| id  | name   | salary | Version | Created By | Deleted By |
| --- | ------ | ------ | ------- | ---------- | ---------- |
| 1   | Alice  | 5000   | 1       | \( T_0 \)  | NULL       |
| 2   | Bob    | 6000   | 1       | \( T_0 \)  | NULL       |
| 3   | Charlie| 7000   | 1       | \( T_0 \)  | NULL       |

#### 场景描述：
- 事务 \( T_1 \) 读取所有工资大于 5500 的员工信息，并将他们的工资增加 500。
- 事务 \( T_2 \) 同时将 Bob 的工资从 6000 降低到 5500。

### 步骤 1：事务 \( T_1 \) 开始
- \( T_1 \) 读取表的快照，看到当前表中 Bob 的工资为 6000，符合条件。
- 此时 \( T_1 \) 准备将 Bob 的工资增加 500，并读取了 Bob 的版本 1。

```markdown
T1 快照视图：

| id  | name   | salary | Version | Created By | Deleted By |
| --- | ------ | ------ | ------- | ---------- | ---------- |
| 1   | Alice  | 5000   | 1       | \( T_0 \)  | NULL       |
| 2   | Bob    | 6000   | 1       | \( T_0 \)  | NULL       |
| 3   | Charlie| 7000   | 1       | \( T_0 \)  | NULL       |
```

### 步骤 2：事务 \( T_2 \) 更新 Bob 的工资
- \( T_2 \) 将 Bob 的工资从 6000 降低到 5500。
- 数据库会为 Bob 创建一个新的版本，记录为版本 2，旧的版本 1 对其他事务仍然可见。

```markdown
数据库状态：

| id  | name   | salary | Version | Created By | Deleted By |
| --- | ------ | ------ | ------- | ---------- | ---------- |
| 1   | Alice  | 5000   | 1       | \( T_0 \)  | NULL       |
| 2   | Bob    | 6000   | 1       | \( T_0 \)  | \( T_2 \)  |
| 2   | Bob    | 5500   | 2       | \( T_2 \)  | NULL       |
| 3   | Charlie| 7000   | 1       | \( T_0 \)  | NULL       |
```

### 步骤 3：事务 \( T_1 \) 提交修改
- \( T_1 \) 打算将 Bob 的工资从 6000 提升到 6500，然而它并没有看到 Bob 被 \( T_2 \) 更新的版本 2（即 Bob 的新工资 5500）。
- \( T_1 \) 创建 Bob 的新版本，工资为 6500。

```markdown
数据库状态：

| id  | name   | salary | Version | Created By | Deleted By |
| --- | ------ | ------ | ------- | ---------- | ---------- |
| 1   | Alice  | 5000   | 1       | \( T_0 \)  | NULL       |
| 2   | Bob    | 6000   | 1       | \( T_0 \)  | \( T_2 \)  |
| 2   | Bob    | 5500   | 2       | \( T_2 \)  | \( T_1 \)  |
| 2   | Bob    | 6500   | 3       | \( T_1 \)  | NULL       |
| 3   | Charlie| 7000   | 1       | \( T_0 \)  | NULL       |
```

### 结果：
- \( T_1 \) 读取了旧版本的 Bob（6000），并创建了一个新的版本，将其工资提升到 6500。
- \( T_2 \) 在并发过程中将 Bob 的工资降至 5500，但由于 \( T_1 \) 使用的快照没有看到 \( T_2 \) 的修改，它在 \( T_2 \) 后又重新更新了 Bob 的工资。

### 总结：
- **多版本并发控制（MVCC）** 通过维护对象的多个版本，允许读写并发执行，避免写操作阻塞读操作。
- **快照隔离** 确保每个事务看到的是开始时的数据库状态，而不会受到其他事务写操作的干扰。这在只读事务中非常有用，但可能导致**写偏斜异常**（如上例中的工资变化）。

---

**典型的基于 MVCC 的数据库设计包括以下步骤：**
- 1. 存储多个版本，用于存储相同逻辑对象的**不同版本**。
- 2. 当事务开始时，DBMS 通过**复制**事务状态表来获取数据库的快照。
- 3. DBMS 使用快照来确定哪些版本的对象对事务可见。

**MVCC 的五个重要设计决策：**
- 1. 并发控制协议
- 2. 版本存储
- 3. 垃圾回收
- 4. 索引管理
- 5. 删除

并发控制协议可以从之前讨论的各种方案中选择（如两阶段锁、时间戳排序、乐观并发控制）。

#### 快照隔离 (Snapshot Isolation)
快照隔离为事务提供了一个一致的数据库快照，供其在开始时使用。快照中的数据值只来自已提交的事务，事务在整个执行过程中与其他事务完全隔离。**只读事务**在这种情况下非常理想，因为它们不需要等待其他事务的写操作。写操作存储在事务的私有工作区中，或者带有事务元数据的存储中，只有当事务成功提交时，这些写入才对数据库可见。

- **写冲突**：如果两个事务更新同一个对象，**第一个写入者胜出**。
- **写偏斜异常**：在快照隔离下，如果两个并发事务修改了不同的对象，可能会导致不可串行化的调度。例如，一个事务将所有白色弹珠变为黑色，另一个将所有黑色弹珠变为白色，最终的结果可能不对应于任何串行化调度。

### 3. 版本存储 (Version Storage)
这部分讨论了 DBMS 如何存储逻辑对象的不同物理版本，以及事务如何找到对其可见的最新版本。

DBMS 使用元组的指针字段为每个逻辑元组创建一个**版本链**，这本质上是一个按时间戳排序的链表。这样可以使 DBMS 在运行时找到对某个事务可见的版本。索引总是指向版本链的“头部”，即最新或最旧的版本，具体取决于实现。一个线程沿着链遍历，直到找到正确的版本。

#### 版本存储的不同方法：
- **方法 1：仅追加存储（Append-Only Storage）**：所有逻辑元组的物理版本存储在同一个表空间中。版本混合存储在表中，每次更新都会将元组的新版本追加到表中，并更新版本链。链可以按照从旧到新 (O2N) 或从新到旧 (N2O) 的顺序排序，前者在查找时需要遍历链，而后者则需要在每次创建新版本时更新索引指针。
    <img src="./18 pictrue/2.png" alt="" width="600" height="350">
  
- **方法 2：时间旅行存储（Time-Travel Storage）**：DBMS 维护一个称为“时间旅行表”的单独表，用于存储元组的旧版本。每次更新时，DBMS 将元组的旧版本复制到时间旅行表中，并将新数据写入主表。主表中的元组指针指向过去的版本。
  <img src="./18 pictrue/3.png" alt="" width="600" height="350">


- **方法 3：增量存储（Delta Storage）**：类似于时间旅行存储，但 DBMS 只存储元组之间的**差异（Delta）**，而不是整个元组。这些差异存储在称为增量存储段的地方。事务可以通过逆序遍历这些差异并应用它们来重建旧版本。这比时间旅行存储有更快的写入速度，但读取速度较慢。
    <img src="./18 pictrue/4.png" alt="" width="600" height="350">

---

### 时间旅行多版本存储示例：

用 `employees` 表来举例：

#### 初始化数据：

```sql
CREATE TABLE employees (
  id INT PRIMARY KEY,
  name VARCHAR(50),
  salary INT
);

-- 插入初始数据
INSERT INTO employees (id, name, salary) VALUES (1, 'Alice', 5000);
INSERT INTO employees (id, name, salary) VALUES (2, 'Bob', 6000);
INSERT INTO employees (id, name, salary) VALUES (3, 'Charlie', 7000);
```

**主表**（初始状态）：

| id  | name   | salary |
| --- | ------ | ------ |
| 1   | Alice  | 5000   |
| 2   | Bob    | 6000   |
| 3   | Charlie| 7000   |

#### 步骤 1：事务更新 Bob 的工资

事务在 `2024-09-01` 将 Bob 的工资从 6000 更新到 6500。

```sql
UPDATE employees SET salary = 6500 WHERE id = 2;
```

此时，数据库会将 Bob 的旧版本（6000）保存到**时间旅行表**中，并在**主表**中存储新版本。

#### 步骤 2：再次更新 Bob 的工资

之后在 `2024-09-05`，另一个事务将 Bob 的工资从 6500 更新到 7000。

```sql
UPDATE employees SET salary = 7000 WHERE id = 2;
```

这时，数据库会将 Bob 的先前版本（6500）保存到时间旅行表，更新主表中的记录为最新的工资（7000）。

### 数据库状态：

#### 主表：

| id  | name   | salary | old_version_ptr |
| --- | ------ | ------ | --------------- |
| 1   | Alice  | 5000   | NULL            |
| 2   | Bob    | 7000   | -> old_version_2|
| 3   | Charlie| 7000   | NULL            |

#### 时间旅行表：

| id  | name   | salary | version_created | version_deleted |
| --- | ------ | ------ | ----------------| ----------------|
| 2   | Bob    | 6000   | '2024-09-01'    | '2024-09-05'    |
| 2   | Bob    | 6500   | '2024-09-05'    | NULL            |

### 解释：

1. **主表**：始终存储的是当前最新的数据版本。在我们的例子中，Bob 的最新工资是 7000。
2. **时间旅行表**：存储的是 Bob 的旧版本数据。在这个例子中，时间旅行表中存储了两个旧版本：
   - Bob 在 `2024-09-01` 的工资为 6000，并在 `2024-09-05` 这天更新为 6500。
   - Bob 的工资再次更新到 7000 时，时间旅行表会记录 Bob 在 `2024-09-05` 时的工资（6500），并将其保存为历史版本。

### 多版本查询：

如果你想查询 `2024-09-02` 时 Bob 的工资，可以执行**时间旅行查询**，DBMS 会从时间旅行表中找到适合的版本：

```sql
SELECT * FROM employees AS OF TIMESTAMP '2024-09-02';
```

**查询结果**：

| id  | name   | salary |
| --- | ------ | ------ |
| 1   | Alice  | 5000   |
| 2   | Bob    | 6000   |
| 3   | Charlie| 7000   |

如果你想查询 `2024-09-06` 时 Bob 的工资，数据库会返回当前版本的最新数据：

```sql
SELECT * FROM employees AS OF TIMESTAMP '2024-09-06';
```

**查询结果**：

| id  | name   | salary |
| --- | ------ | ------ |
| 1   | Alice  | 5000   |
| 2   | Bob    | 7000   |
| 3   | Charlie| 7000   |

### 总结：

在**时间旅行存储**中，数据库会保存**多个旧版本**的数据，每次更新时都不会直接覆盖当前数据，而是将旧版本保存到时间旅行表。这样，数据库能够查询过去任何时间点的状态，而不仅仅是保存最近的一个旧版本。

- **主表**：始终保存最新版本。
- **时间旅行表**：保存历史版本，支持时间旅行查询。


---

### 4. 垃圾回收 (Garbage Collection)
DBMS 需要随着时间的推移，从数据库中删除可回收的物理版本。如果某个版本对任何活动事务都不可见，或者该版本是由已中止的事务创建的，那么它就是可回收的。

#### 垃圾回收的不同方法：
- **方法 1：基于元组的垃圾回收**：DBMS 通过直接检查元组来找到旧版本。主要有两种方式：
  - **后台清理（Background Vacuuming）**：单独的线程会定期扫描表，寻找可回收的版本。此方法适用于任何版本存储方案。一个简单的优化是维护一个“脏页位图”，跟踪自上次扫描以来已修改的页面，允许线程跳过未修改的页面。
  - **协作清理（Cooperative Cleaning）**：工作线程在遍历版本链时识别可回收的版本。这仅适用于 O2N 链。如果数据不被访问，就永远不会被清理。
  
- **方法 2：基于事务的垃圾回收**：每个事务负责跟踪自己的旧版本，因此 DBMS 不需要扫描元组。每个事务维护自己的读/写集合。当事务完成时，垃圾回收器可以使用这些集合来识别哪些元组可以回收。DBMS 会确定已完成事务创建的所有版本何时不再可见。

### 5. 索引管理 (Index Management)
所有主键索引 (pkey) 总是指向版本链的头部。DBMS 更新主键索引的频率取决于系统在更新元组时是否创建新版本。如果事务更新了主键属性，则此操作被视为先删除，再插入。

管理**二级索引**（secondary index）更为复杂，主要有两种方法：
- **方法 1：逻辑指针**：DBMS 为每个元组使用一个固定的标识符，该标识符不会更改。这需要一个额外的间接层，将逻辑 ID 映射到元组的物理位置。元组更新时，只需更新间接层中的映射。
  
- **方法 2：物理指针**：DBMS 使用指向版本链头部的物理地址。这种方式需要在版本链头更新时更新每个索引，代价很高。

通常，MVCC 数据库索引不会与键一起存储元组的版本信息。相反，每个索引必须支持不同快照中的**重复键**，因为相同的键可能在不同的快照中指向不同的逻辑元组。工作线程在单次查询中可能返回多个条目，然后它们需要跟随指针找到适合的物理版本。

### 6. 删除 (Deletes)
DBMS 只有在所有逻辑删除的元组版本都不可见时，才会物理删除元组。如果一个元组被删除了，则在最新版本之后不能再有新版本。这意味着不会发生写写冲突，第一个写入者胜出。

我们需要一种方法来表示某个元组在某个时间点被逻辑删除。主要有两种方法：
- **方法 1：删除标志**：维护一个标志，指示该逻辑元组在最新物理版本之后被删除。这个标志可以在元组头部或者一个单独的列中。
  
- **方法 2：墓碑元组（Tombstone Tuple）**：创建一个空的物理版本，表示某个逻辑元组已被删除。使用一个单独的墓碑元组池，只有在版本链指针中包含特定的位模式时，才会降低存储开销。