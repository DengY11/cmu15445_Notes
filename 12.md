# CMU15445 12

## 查询处理1

### 1. 查询计划
DBMS将SQL语句转换为**查询计划**(query plan.)，查询计划中的操作符按**树状结构**排列，数据从树的叶子节点流向根节点，根节点的输出是查询的结果。通常，这些操作符是二元的（有1-2个子节点）。相同的查询计划可以通过多种方式执行。

### 2. 处理模型
DBMS处理模型定义了系统如何执行查询计划，具体包括查询计划的评估方向及操作符之间的数据传递方式。不同的处理模型适用于不同的工作负载，并具有不同的权衡。可以**从上至下**或**从下至上**调用操作符，虽然上至下的调用更为常见，但下至上的方法可以**更好地控制缓存/寄存器**。

我们考虑三种执行模型：

- **迭代器模型** (Iterator Model)
- **物化模型** (Materialization Model)
- **向量化/批量模型** (Vectorized/Batch Model)

#### 2.1 迭代器模型
迭代器模型，又称**Volcano或Pipeline**模型，是最常见的处理模型，几乎被所有基于行的DBMS采用。

- 每个操作符实现一个 **Next 函数**。
- 查询计划中的每个节点调用其**子节点**的 Next 直到叶节点开始向父节点发出元组。
- 每个元组在被完全处理之前会被尽可能向上传递。这对基于磁盘的系统很有用，因为它允许在访问下一个元组或页面之前充分利用内存中的每个元组。
- 一些操作符会在其子节点发出所有元组之前阻塞，这些操作符称为**管道断点pipeline breakers**（如连接操作、子查询、排序）。
<img src="./12 pictrue/1.png" alt="图片描述" width="600" height="300">
**优点：高可组合性、易于推理。**

**EXAMPLE:**
```sql
SELECT * FROM employees WHERE age > 30;
```
此查询的查询计划可能包含两个操作符：SeqScan（顺序扫描）操作符和Filter（过滤）操作符。

Filter操作符（根节点）调用其子节点SeqScan的Next()函数来获取一个元组。
SeqScan操作符读取**一个元组**（例如{id: 1, name: "Alice", age: 35}）并返回给Filter。(**注意:一次只读1个tuple**)
Filter操作符检查元组的年龄字段，如果条件满足（例如，age > 30），则将该元组返回给父操作符（此处没有父操作符，因为它是根节点）。
Filter操作符再次调用SeqScan的Next()函数以获取下一个元组，重复上述步骤，直到所有元组处理完毕。

#### 2.2 物化模型
物化模型是迭代器模型的一种特化版本，每个操作符一次性处理其**所有输入**，并一次性发出其输出。

每个操作符都有一个 Output 函数，它处理所有子节点的元组并返回所有元组作为结果。
适用于OLTP工作负载(去看第5课笔记)，因为查询通常只一次访问少量元组。
缺点：不适合OLAP查询，因为中间结果可能会溢出到磁盘。
<img src="./12 pictrue/2.png" alt="图片描述" width="600" height="300">

#### 2.3 向量化模型
与迭代器模型类似，向量化模型中的每个操作符实现一个 Next 函数，但每次发出的是**一批数据**而不是单个元组。
<img src="./12 pictrue/3.png" alt="图片描述" width="600" height="300">
适合需要扫描大量元组的OLAP查询，因为**减少了 Next 函数的调用次数**。
操作符可以更容易使用向量化（SIMD）指令来处理数据批次。

### 3. 访问方法
访问方法决定了DBMS如何访问存储在表中的数据，主要有顺序扫描和索引扫描两种方式。

#### 3.1 顺序扫描
顺序扫描操作符遍历表中的每一页，从缓冲池中检索数据。

优化方法：

- **预取**：提前获取下一页，避免存储I/O阻塞。
- **缓冲池绕过(Buffer Pool Bypass)**：将页存储在本地内存中，避免顺序泛洪。
- **并行化**：使用多线程/进程并行执行扫描。
- **晚物化**：在列存储系统中延迟拼接元组，减少传递信息量。
- **堆聚集(Heap Clustering)**：按照聚集索引的顺序存储元组。
- **近似查询(Approximate Queries (Lossy Data Skipping))**：在允许低误差的情况下，通过抽样子集执行查询。
- **区域图(zone map)**：预先计算每个页面的聚合信息，避免不必要的页面访问。
  <img src="./12 pictrue/4.png" alt="图片描述" width="600" height="200">
#### 3.2 索引扫描
索引扫描根据**查询需求**选择索引来**查找元组**。DBMS的索引选择过程涉及多个因素，如索引包含的属性、查询引用的属性、属性值的域、谓词的组成等。
<img src="./12 pictrue/5.png" alt="" width="600" height="300">
- *Consider a single table with 100 tuples and two
indexes: age and department. In the first scenario, it is better to use the department
index in the scan because it only has two tuples to match. Choosing the age index
would not be much better than a simple sequential scan. In the second scenario, the
age index would eliminate more unnecessary scans and is the optimal choice.*

**多索引扫描**：可以结合多个索引的结果集，通过位图、哈希表或Bloom过滤器计算记录ID。
### 4. 修改查询
修改数据库的操作符（如INSERT、UPDATE、DELETE）需要检查约束并更新索引。
<img src="./12 pictrue/6.png" alt="" width="600" height="300">
处理INSERT的两种选择：**物化元组**或**直接插入从子操作符传递过来的元组**。

#### 万圣节问题（Halloween Problem）
数据库系统中出现的一种更新异常情况，指在执行UPDATE操作时，因更新改变了元组的物理存储位置，导致查询处理器重复访问并更新同一个元组多次的现象。该问题首次于1976年在IBM的System R数据库项目中被发现，因发现日是万圣节而得名。
##### 原因
当一个查询操作修改一个表中元组的值（例如，增加工资），同时使用索引来遍历这些元组时，如果修改导致元组的位置在索引中变化，查询操作可能会重新访问同一个元组，造成逻辑错误。
##### 解决方法
解决万圣节问题的方法是避免在扫描期间直接修改原始数据，常见的方法包括：
- **使用临时表**：将要更新的元组先存入临时表，扫描完成后再进行批量更新。
- **延迟写操作**：首先收集所有需要更新的元组ID，再一次性执行更新。
这样可以确保每个元组只被处理一次，避免重复更新。

### 5. 表达式评估
DBMS使用表达式树来表示WHERE子句。执行时，DBMS维护一个包含元数据的上下文句柄，并遍历表达式树来计算结果。
<img src="./12 pictrue/7.png" alt="" width="600" height="300">
直接评估表达式（类似于JIT编译和gcc -o2）比逐步遍历树的方式更快。
#### 表达式树
##### 结构：
- 表达式树是一种树形结构，节点表示操作符（如比较、算术运算）或操作数（如常量、列值）。例如，表达式(a + b) * c的树结构中，*是根节点，+和c是它的子节点，而a和b又是+的子节点。
##### 节点类型：
- 比较操作符：=, <, >, !=等。
- 逻辑操作符：AND, OR, NOT等。
- 算术操作符：+, -, *, /等。
- 常量和参数：如5，'USA'等。
- 元组属性引用：如employee.age等。
##### 表达式评估的过程
- 表达式树构建：DBMS将SQL查询解析成表达式树，树的每个节点表示一个操作符或操作数。

##### 上下文（Context）维护：
- 在评估过程中，DBMS维护一个上下文，包含执行所需的元数据（如当前元组、参数值、表的模式等）。

##### 运行时优化：

- **短路求值**（Short-circuit Evaluation）：对于AND和OR这样的逻辑操作符，DBMS会在确定结果后立即停止后续计算。
- **直接代码生成**（JIT, Just-In-Time Compilation）：为了提高复杂表达式的评估速度，DBMS可能会直接生成计算机代码而不是使用通用的解释器。

##### 表达式评估的优化
- **索引利用**：在表达式中，DBMS会检查能否利用索引来快速筛选数据。
- **常量折叠和简化**：将可以在编译时计算的常量进行折叠，以减少运行时的计算量。
- **表达式重排序**：对表达式进行重排序，使得评估代价最小（例如，先评估选择性高的条件）。
示例
### 6. 调度器(Scheduler)
调度器通过分离**数据流**（Data Flow）和**控制流**（Control Flow）来优化查询执行。它将查询计划操作符的执行任务分解成多个小的、独立的工作单元（称为工作订单（Work Orders）），然后将这些工作订单放入调度队列中，由多个工作线程动态地从队列中取出并执行。
<img src="./12 pictrue/8.png" alt="" width="600" height="300">
优点：抽象清晰、动态优化、内置查询挂起、更好的性能和可管理性。

