# CMU15445 11

## 连接 (Joins)

良好的数据库设计的目标是尽量**减少信息的重复**。这就是为什么表格的设计基于**规范化理论**( normalization theory)。因此，需要通过连接操作来重建原始表格。我们重点讨论将两个表格结合的内部等值连接算法。等值连接算法用于连接那些键值相等的表格。这些算法可以进行调整以支持其他类型的连接。

### 操作符输出
<img src="./11 pictrue/1.png" alt="图片描述" width="600" height="300">

对于表 R 中的元组 r 和表 S 中在连接属性上匹配的元组 s，**连接操作符**(join operator)将 r 和 s 拼接成一个新的输出元组。实际上，由连接操作符生成的输出元组的内容**各不相同**。这取决于 DBMS的查询处理模型、存储模型以及查询本身。连接操作符的输出内容有多种实现方式。

- **数据**：这种方法将外部表和内部表中的属性值**复制到一个中间结果表**中，只用于该操作符。此方法的优点是查询计划中的后续操作符**不再需要返回基表**以获取更多数据。缺点是需要**更多的内存**来具体化整个元组。这被称为**early materialization**。DBMS 还可以进行额外的计算并省略查询中不需要的属性，以进一步优化这种方法。

- **记录 ID**：在这种方法中，DBMS 只复制连接键和匹配元组的**记录 ID**。这种方法对列存储特别理想，因为 DBMS 不会复制查询不需要的数据。这被称为**late materialization**。

### 成本分析

这里用来分析不同连接算法的成本指标是计算连接所需的磁盘 **I/O 次数**。这包括从磁盘读取数据所产生的 I/O 以及将任何中间数据写入磁盘的 I/O。我们的目标是在基于磁盘的系统中**减少连接的 I/O 操作**，忽略计算成本，因为 I/O 成本占主导地位。注意，这里只考虑计算连接所需的 I/O，而不包括输出结果时的 I/O，因为输出成本取决于数据，而且任何连接算法的输出都是相同的，因此在不同算法之间成本不会变化。

使用的变量：
- R 表（外部表）中有 M 页，总共 m 个元组。
- S 表（内部表）中有 N 页，总共 n 个元组。

请注意，**R ▷◁ S**（表 R 和 S 的自然连接）是最常见的操作，必须谨慎优化。一个低效的算法可能涉及计算**R × S**（表 R 和 S 的笛卡尔积）并选择相关的元组。然而，**笛卡尔积非常庞大**，导致非常低效的方法。一般来说，许多算法/优化可以在某些情况下减少连接成本，但没有单一的算法在所有场景下都表现良好。

---

## 嵌套循环连接 (Nested Loop Join)

<img src="./11 pictrue/2.png" alt="图片描述" width="600" height="300">

从高层次上看，这种连接算法由**两个嵌套的 for 循环组成**，它们遍历两个表中的元组，并逐一比较它们。如果元组符合连接谓词，则输出它们。外层 for 循环中的表称为**外部表**，而内层 for 循环中的表称为**内部表**。DBMS 通常会选择**较小的表作为外部表**。较小可以指元组数量较少或者页数较少的表。DBMS 还会尽量将外部表尽可能多的部分缓存在内存中。它还可以尝试利用索引在内部表中查找匹配项。

- **简单嵌套循环连接 (Naive Nested Loop Join)**：
  对于外部表中的每个元组，比较它与内部表中的每个元组。这是最坏的情况，DBMS 必须为外部表中的每个元组执行一次内部表的完整扫描，而没有任何缓存或访问局部性。
  - **成本：M + (m × N)**

- **块嵌套循环连接 (Block Nested Loop Join)**：
  对于外部表中的每个块，获取内部表中的每个块并比较这两个块中的所有元组。该算法执行更少的磁盘访问，因为 DBMS 在每个外部表块上扫描内部表，而不是在每个元组上扫描。
  - **成本：M + （R 中的块数 × N）**

如果 DBMS 有 B 个缓冲区用于计算连接，那么它可以使用 B−2 个缓冲区来扫描外部表。它将使用一个缓冲区来扫描内部表，另一个缓冲区用于存储连接的输出。
  - **成本：M + (⌈ M / (B−2) ⌉ × N)**
<img src="./11 pictrue/3.png" alt="图片描述" width="600" height="300">
---

## 索引嵌套循环连接 (Index Nested Loop Join)

之前的嵌套循环连接算法表现不佳，因为 DBMS 必须执行顺序扫描以检查内部表中的匹配项。然而，**如果数据库已经为某个表的连接键建立了索引，它可以利用这一点来加速比较**。DBMS 可以使用现有索引或为连接操作**构建一个临时索引**。外部表将是没有索引的表。内部表将是有索引的表。假设每次索引查找的成本为每个元组的某个常数 C。
- 成本：M + (m × C)

---

## 排序-合并连接 (Sort-Merge Join)

从高层次上看，排序-合并连接（Sort-Merge Join）会根据**连接键**（join key）对两个表进行排序。DBMS 可以使用外部归并排序算法（external mergesort algorithm）来实现这一点。然后，它使用游标（cursors）遍历每个表并发出匹配项（类似于归并排序）。

如果一个或两个表已经在连接属性（join attribute）上进行了排序（如使用聚簇索引 clustered index），**或者输出需要在连接键上进行排序**，那么这种算法非常有用。

这种算法的**最坏**情况是，**如果两个表中所有元组的连接属性都包含相同的值**，这在实际数据库中极不可能发生。在这种情况下，合并的成本将是 **M×N**。但大多数情况下，键值（key）大多是唯一的，因此合并成本大约是 **M+N**。


假设 DBMS 有 B 个缓冲区用于算法：

- **表 R 的排序成本：2M × (1 + ⌈logB−1⌈M/B⌉⌉)**
- **表 S 的排序成本：2N × (1 + ⌈logB−1⌈N/B⌉⌉)**
- **合并成本：M + N**

总成本：排序 + 合并

---

## 哈希连接 (Hash Join)


<img src="./11 pictrue/4.png" alt="图片描述" width="600" height="300">

哈希连接算法的高层次思想是利用哈希表根据连接属性（join attribute）将元组拆分成**更小的块**。这减少了 DBMS在计算连接时每个元组所需的比较次数。哈希连接只能用于在**完整连接键**（complete join key）上的**等值连接**（equi-join）。

如果元组 \( r \in R \) 和元组 \( s \in S \) 满足连接条件，那么它们的连接属性具有相同的值。如果这个值被哈希（hashed）为某个值 \( i \)，那么 \( R \) 表的元组就会在桶（bucket）\( r_i \) 中，而 \( S \) 表的元组则在桶 \( s_i \) 中。因此，\( r_i \) 桶中的 \( R \) 表元组只需要与 \( s_i \) 桶中的 \( S \) 表元组进行比较。




### 基本哈希连接 (Basic Hash Join)

- **阶段 #1 – 构建 (Build)**：首先扫描外部关系并使用哈希函数 h1 根据连接属性填充哈希表。哈希表中的键是连接属性。值取决于实现（可以是完整的元组值或元组 ID）。
  
- **阶段 #2 – 探测 (Probe)**：扫描内部关系并使用哈希函数 h1 对每个元组的连接属性进行哈希，以跳转到哈希表中的相应位置并找到匹配的元组。由于哈希表中可能存在碰撞，DBMS 需要检查连接属性的原始值，以确定元组是否真正匹配。

如果 DBMS 知道外部表的大小，则连接可以使用**静态哈希表**。如果不知道，则连接必须使用**动态哈希表或允许溢出页**。探测阶段的一个优化是使用布隆过滤器（Bloom Filter）。这是一种概率数据结构，可以适合在 CPU 缓存中使用，并回答“键 x 是否在哈希表中？”的问题，答案要么是“肯定不在”，要么是“可能在”。它通过防止不匹配的磁盘读取来减少磁盘 I/O。
### 举个简单例子
假设我们有两个表，`Employees` 表和 `Departments` 表，分别描述公司员工的信息和部门的信息。我们想通过部门 ID 来连接这两个表，以获取每个员工及其所属部门的详细信息。

- **Employees 表**（员工表）：
  | EmployeeID | Name    | DepartmentID |
  |------------|---------|--------------|
  | 1          | Alice   | 10           |
  | 2          | Bob     | 20           |
  | 3          | Charlie | 10           |
  | 4          | David   | 30           |

- **Departments 表**（部门表）：
  | DepartmentID | DepartmentName  |
  |--------------|-----------------|
  | 10           | HR              |
  | 20           | Engineering     |
  | 30           | Marketing       |
  | 40           | Sales           |

我们要进行的连接操作是通过 `DepartmentID`（部门 ID）连接 `Employees` 表和 `Departments` 表。

### 哈希连接的步骤：
1. **阶段 1 - 构建（Build Phase）**：
   - 首先，我们选择其中一个表作为构建表（通常选择较小的表）。在本例中，我们选择 `Departments` 表作为构建表。
   - 我们使用 `DepartmentID` 作为哈希键，将 `Departments` 表中的每一行插入到哈希表（hash table）中。哈希表中的键是 `DepartmentID`，值可以是整个 `Department` 行，或仅仅是 `DepartmentID` 和 `DepartmentName`。

   哈希表的构建结果如下：

   | 哈希值 (hash value) | 桶 (Bucket) |
   |---------------------|-------------|
   | h(10)               | 10, HR      |
   | h(20)               | 20, Engineering |
   | h(30)               | 30, Marketing   |
   | h(40)               | 40, Sales       |

2. **阶段 2 - 探测（Probe Phase）**：
   - 接下来，我们扫描 `Employees` 表，将每一行的 `DepartmentID` 应用相同的哈希函数（hash function），以确定其哈希值并找到相应的桶。
   - 例如，对于 Alice，她的 `DepartmentID` 是 10，所以我们将她的 `DepartmentID` 应用哈希函数 `h(10)`，并将她的记录与哈希表中 `h(10)` 对应的桶进行比较，发现 HR 部门。

   执行过程如下：
   
   - Alice (`DepartmentID` = 10) 的哈希值是 `h(10)`，对应的部门是 HR。因此，输出结果：`(Alice, HR)`
   - Bob (`DepartmentID` = 20) 的哈希值是 `h(20)`，对应的部门是 Engineering。因此，输出结果：`(Bob, Engineering)`
   - Charlie (`DepartmentID` = 10) 的哈希值是 `h(10)`，对应的部门是 HR。因此，输出结果：`(Charlie, HR)`
   - David (`DepartmentID` = 30) 的哈希值是 `h(30)`，对应的部门是 Marketing。因此，输出结果：`(David, Marketing)`

### 最终结果：
经过哈希连接，我们得到以下结果表：

| EmployeeID | Name    | DepartmentID | DepartmentName |
|------------|---------|--------------|----------------|
| 1          | Alice   | 10           | HR             |
| 2          | Bob     | 20           | Engineering    |
| 3          | Charlie | 10           | HR             |
| 4          | David   | 30           | Marketing      |


### Grace 哈希连接/分区哈希连接 (Grace Hash Join / Partitioned Hash Join)

Grace 哈希连接（Grace Hash Join）和基本的哈希连接（Basic Hash Join）在概念上相似，但它们之间有一些关键区别，主要体现在如何处理内存不足时的情况。

### 基本哈希连接（Basic Hash Join）

**基本哈希连接的工作原理：**

1. **构建阶段（Build Phase）**：
   - 首先扫描其中一个表（通常是较小的表，称为构建表），并使用哈希函数根据连接键将其分散到多个哈希桶中。哈希表会保存在内存中。

2. **探测阶段（Probe Phase）**：
   - 然后扫描另一个表（探测表），将探测表中的每一行通过相同的哈希函数进行哈希，然后查找对应的哈希桶，并在相应的哈希桶中进行连接操作。

**局限性：**
- 基本哈希连接假设构建表可以完全放入内存中。如果构建表过大，无法完全装入内存，则需要一种机制来处理这种情况，否则可能导致性能问题或无法完成连接操作。

### Grace 哈希连接（Grace Hash Join）

**Grace 哈希连接的工作原理：**


<img src="./11 pictrue/6.png" alt="图片描述" width="600" height="300">


Grace 哈希连接是对基本哈希连接的一种扩展，专门用于处理表格较大、无法完全放入内存的情况。它通过将表格分区并部分存储在磁盘上来处理内存不足的问题。

1. **分区阶段（Partitioning Phase）**：
   - 首先，使用哈希函数将两个表（构建表和探测表）分别分区。将表格按照哈希值分为多个较小的部分，这些部分可以分别存入磁盘。每个分区都会被哈希到不同的桶中，并写回到磁盘上。

2. **构建和探测阶段（Build and Probe Phases）**：
   - 对于每个分区，Grace 哈希连接会将相应的分区加载到内存中，并在内存中进行哈希连接操作。这与基本哈希连接类似，但因为每个分区都较小，能够装入内存，所以可以有效处理。

**关键优势：**
- **处理大表**：Grace 哈希连接的一个显著优势是它能够处理内存不足的情况，即当表格非常大时，它可以通过分区使得每次只处理表格的一小部分，从而避免内存溢出。
- **递归分区**：如果初次分区后，某些分区仍然过大，Grace 哈希连接可以再次对这些分区进行递归分区，直到每个分区可以装入内存。

### 比较

- **基本哈希连接** 适用于内存足够大的情况，即构建表可以完全放入内存中。
- **Grace 哈希连接** 则设计用来处理无法一次性将表格全部加载到内存的情况。通过分区，Grace 哈希连接能够有效地将问题拆解，使得每次只需处理较小的分区，避免内存限制的影响。


一个具有 N 页的表大约需要 √N 个缓冲区。上述方法在阶段 #1 中创建 B−1 个溢出分区，每个分区大小最多为 B−2 块。因此，假设哈希函数均匀分布记录，可以哈希的最大表大小为 (B−1) × (B−2) 个缓冲区。如果哈希函数不均匀，可以引入一个调整因子 f > 1，因此最大表大小为 B × √f × N。

- **分区阶段成本：2 × (M + N)**
- **探测阶段成本：M + N**
- **总成本：3 × (M + N)**


### 场景描述：
假设我们有两个大表：`Employees` 表和 `Departments` 表。我们想通过 `DepartmentID` 将这两个表连接在一起。假设：

- **Employees 表**（包含员工信息，有 1,000,000 条记录，每条记录大约占 100 字节）
- **Departments 表**（包含部门信息，有 10,000 条记录，每条记录大约占 100 字节）

假设内存可以容纳 100,000 条记录（大约 10 MB 的内存）。



在基本哈希连接中，我们假设 `Departments` 表可以完全放入内存中：

假设 `Departments` 表太大，无法一次性装入内存，我们需要使用 Grace 哈希连接来处理。

1. **分区阶段（Partitioning Phase）**：
   - 使用哈希函数 `h1(x)` 将 `Employees` 表和 `Departments` 表分区。具体操作是：
     - 对 `Departments` 表进行一次扫描，根据 `DepartmentID` 使用哈希函数 `h1(x)`，将记录分为多个分区（例如分为 10 个分区）。每个分区都写入磁盘的一个单独文件中。
     - 对 `Employees` 表进行类似的操作，使用相同的哈希函数 `h1(x)`，将其分为相同数量的分区，并将分区数据写入磁盘。
   - 由于每个分区数据量较小，分区文件通常可以分别装入内存。

2. **构建和探测阶段（Build and Probe Phases）**：
   - 对于每个分区，执行以下步骤：
     - 从磁盘加载 `Departments` 表的**一个分区到内存**，构建哈希表。
     - 从磁盘加载 `Employees` 表的**对应分区到内存**，进行哈希探测，查找匹配的 `DepartmentID`，并输出结果。

3. **递归分区（如有必要）**：
   - 如果某个分区仍然太大，无法完全装入内存，Grace 哈希连接可以对该分区再次进行哈希分区处理，直到每个分区足够小，可以装入内存。

### 结果比较

- **基本哈希连接**：适用于内存足够大，能够一次性装入整个构建表（在这个例子中是 `Departments` 表）的情况。
- **Grace 哈希连接**：即使表格很大，超出了内存容量，Grace 哈希连接仍然可以通过分区和逐步处理来完成连接操作。



### 总结

Grace 哈希连接通过分区处理，解决了大表格无法一次性装入内存的问题，是基本哈希连接的扩展和优化版本。它更适合用于处理那些超出内存容量的大规模数据集。

### 混合哈希连接优化 (Hybrid Hash Join Optimization)

混合哈希连接优化在基本哈希连接和 Grace 哈希连接之间进行调整；如果键分布不均匀，将热点分区保留在内存中并立即执行比较，而不是将其溢出到磁盘。正确实现这一优化非常困难。

---

## 结论 (Conclusion)

连接是与关系数据库交互的核心部分，因此确保 DBMS 具有执行连接的高效算法非常重要。

| 算法 | I/O 成本 | 示例 |
|------|---------|-----|
| 简单嵌套循环连接 | M + (m × N) | 1.4 小时 |
| 块嵌套循环连接 | M + (M × N) | 50 秒 |
| 索引嵌套循环连接 | M + (m × C) | 变化 |
| 排序-合并连接 | M + N + (排序成本) | 0.75 秒 |
| 哈希连接 | 3 × (M + N) | 0.45 秒 |

表格假设如下：M = 1000，m = 100000，N = 500，n = 40000，B = 100，每次 I/O 为 0.1 ms。排序成本为 R + S = 4000 + 2000 IOs，其中 R = 2 × M × (1 + ⌈logB−1⌈M/B⌉⌉) = 2000 × (1 + ⌈log99⌈1000/100⌉⌉) = 4000，S = 2 × N × (1 + ⌈logB−1⌈N/B⌉⌉) = 1000 × (1 + ⌈log99⌈500/100⌉⌉) = 2000。

哈希连接几乎总是比基于排序的连接算法更好，但在某些情况下，排序连接会更优。包括在非均匀数据上的查询，当数据已经在连接键上排序，以及当结果需要排序时。好的 DBMS 会使用两者或两者兼用。
