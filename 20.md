# CMU 15445 20 
## 数据库崩溃恢复

### 1 崩溃恢复
DBMS依赖其恢复算法来确保数据库的一致性、事务的原子性和持久性，哪怕在发生故障的情况下。这些恢复算法由两个部分组成：
- 正常事务处理期间的操作，以确保DBMS能够从故障中恢复。
- 故障后的操作，用于将数据库恢复到保证事务原子性、一致性和持久性的状态。

数据库弹性管理的关键在于事务完整性和持久性的维护，尤其是在故障场景下。这一基础概念为ARIES恢复算法的介绍奠定了基础。  
**ARIES**（Algorithms for Recovery and Isolation Exploiting Semantics）是IBM研究部门在1990年代初为DB2系统开发的一种恢复算法。

ARIES恢复协议的三个关键概念：
- **Write Ahead Logging (WAL，先写日志)**：在数据库更改写入磁盘之前，所有更改都会先记录在稳定存储上的日志中（STEAL + NO-FORCE策略）。
- **Redo时重复历史**：在重新启动时，重新执行操作，恢复到崩溃前的确切状态。
- **Undo期间记录日志**：记录撤销操作，以确保在发生重复故障时不会再次执行相同操作。

## 2 WAL 日志记录
**Write-ahead log (WAL)** 记录扩展了DBMS的日志记录格式，包括一个**全局唯一的日志序列号（LSN）**。所有日志记录都有一个LSN。下图展示了带有LSN的日志记录的高层次示意图。
每个数据页包含一个pageLSN，即该页最近一次更新的LSN。每当事务修改该页中的记录时，pageLSN都会更新。  
DBMS还会跟踪到目前为止已刷新到磁盘的最大LSN（flushedLSN）。每当DBMS将WAL缓冲区写入磁盘时，内存中的flushedLSN都会更新。

系统中的各个组件会跟踪与它们相关的LSN。下表展示了这些LSN。

| 名称            | 位置   | 定义                               |
| --------------- | ------ | ---------------------------------- |
| flushedLSN      | 内存   | 日志中最后一个已写入磁盘的LSN        |
| pageLSN         | pagex  | pagex的最新更新                    |
| recLSN          | pagex  | pagex自上次刷新后最早的更新        |
| lastLSN         | 活跃事务表 | 管理中的事务Ti的最新记录            |
| MasterRecord    | 磁盘   | 最新检查点的LSN                    |

<img src="./20 pictrue/1.png" alt="" width="600" height="350">

- 图1说明了如何写入日志记录。每个WAL都在每一步递增一个LSN计数器。每个页还保留一个pageLSN和一个recLSN，其中recLSN存储了使该页变脏的第一个日志记录。flushedLSN是指向最后写入磁盘的LSN的指针。在DBMS能够将页面i写入磁盘之前，必须先将日志刷新到pageLSNi ≤ flushedLSN的点。MasterRecord指向上次成功通过的检查点。

### 3 正常执行
每个事务都会调用一系列读写操作，接着是提交或中止。恢复算法必须涵盖这一系列事件。

#### 事务提交
当事务准备提交时，DBMS首先将COMMIT记录写入内存中的日志缓冲区。然后DBMS刷新所有日志记录，直到包括事务的COMMIT记录，并将其写入磁盘。注意，这些日志刷新是顺序的、同步的磁盘写入。每个日志页可以包含多个日志记录。图2展示了事务提交的示意图。

<img src="./20 pictrue/2.png" alt="" width="600" height="350">

- 在事务提交（015）后，日志被刷新，flushedLSN 被修改为指向最后生成的日志记录。稍后，会在日志中写入一个事务结束消息，表明该事务不会再出现。然后，我们可以将内存中的日志修剪到 flushedLSN 所指示的位置。

一旦COMMIT记录安全地存储在磁盘上，DBMS会返回确认给应用程序，表示事务已提交。稍后，DBMS会向日志写入一个特殊的TXN-END记录，表示该事务在系统中已完全结束，不会再有关于它的日志记录。这些TXN-END记录用于内部管理，不需要立即刷新。

#### 事务中止
中止事务是ARIES撤销操作的特殊情况，只应用于单个事务。  
日志记录中添加了一个新的字段，叫做prevLSN，它对应于该事务的上一个LSN。DBMS使用这些prevLSN值来为每个事务维护一个链表，以便更容易地遍历日志找到其记录。

还引入了一种新的日志记录类型，称为补偿日志记录（**Compensation Log Record, CLR**）。CLR描述了撤销先前更新记录的操作。它包含所有更新日志记录的字段，并增加了一个undoNext指针（即下一个待撤销的LSN）。DBMS会像处理其他记录一样将CLRs添加到日志中，但这些记录永远不需要被撤销。此外，DBMS不会等待CLRs刷新到磁盘后再通知应用程序事务已中止。此方法确保了高效的事务管理，尤其是在涉及事务回滚的场景中。

为了中止一个事务，DBMS首先将ABORT记录添加到内存中的日志缓冲区。然后，它按相反的顺序撤销事务的更新，移除其对数据库的影响。对于每个被撤销的更新，DBMS在日志中创建CLR条目并恢复旧值。所有已中止事务的更新被撤销后，DBMS会写入TXN-END日志记录。图3展示了这一过程。

<img src="./20 pictrue/3.png" alt="" width="600" height="350">

- 图3：事务中止——DBMS 为每个事务创建的日志记录维护了一个 LSN 和 prevLSN。当事务中止时，所有先前的更改都会被撤销。当这些被撤销的更改日志条目被写入磁盘后，DBMS 会在日志中添加一个 TXN-END 记录，用于标识该已中止的事务。这表明该事务的所有操作已被彻底回滚，不会再有关于它的任何日志记录。

### 4 检查点
DBMS会定期进行检查点，将缓冲池中的脏页写入磁盘。这用于减少恢复时需要回放的日志量。

#### 非模糊检查点
DBMS在执行检查点时暂停事务和查询的执行，以确保写入磁盘的是数据库的**一致快照**(快照在18讲)。这与前一讲中讨论的方法相同：
- 阻止任何新事务的开始。
- 等待所有活跃的事务执行完毕。
- 将脏页写入磁盘。

尽管此过程影响了运行时性能，但它极大地简化了恢复过程。

#### 略优的阻塞检查点
与之前的检查点方案类似，区别在于DBMS不必等待活跃事务执行完毕。DBMS现在记录检查点开始时的内部系统状态。
- 阻止任何新事务的开始。
- 暂停事务，直到检查点完成。

检查点过程需要记录开始时的内部状态，包括两个关键组件：**活跃事务表（ATT）** 和 **脏页表（DPT）**。  
- **活跃事务表（ATT）**：记录正在运行的事务状态，每个事务的条目在事务提交/中止完成后删除。  
- **脏页表（DPT）**：记录由未提交事务修改但尚未写入磁盘的页的信息。


#### 模糊检查点
模糊检查点允许其他事务继续运行，这是ARIES协议中的做法。DBMS使用额外的日志记录来跟踪检查点边界：  
- **<CHECKPOINT-BEGIN>**：表示检查点的开始，DBMS记录当前的ATT和DPT快照。  
- **<CHECKPOINT-END>**：记录检查点完成时的ATT和DPT。  

检查点完成后，<CHECKPOINT-BEGIN>记录的LSN会记录在MasterRecord中。

### 5 ARIES 恢复
ARIES协议包括三个阶段。系统崩溃后的启动过程中，DBMS按以下步骤执行恢复：

1. **分析阶段**：读取WAL以识别缓冲池中的脏页和崩溃时的活跃事务。ATT告知哪些事务在崩溃时是活跃的，DPT告知哪些脏页可能未写入磁盘。  
2. **重做阶段**：从适当的日志位置开始，重做所有操作（包括即将中止的事务）。  
3. **撤销阶段**：撤销崩溃前未提交的事务的操作。

#### 分析阶段
从数据库MasterRecord LSN找到的最后一个检查点开始：
1. 从检查点开始扫描日志。
2. 如果DBMS找到TXN-END记录，则从ATT中移除该事务。
3. 其他所有记录，将事务添加到ATT，状态为UNDO，事务提交时状态改为COMMIT。
4. 对于更新日志记录，如果页面P不在DPT中，则将P添加到DPT，并将P的recLSN设置为该日志记录的LSN。

#### 重做阶段
此阶段的目标是让DBMS重复历史，重建其崩溃前的状态。它将重新应用所有更新（即使是已中止的事务）并重做CLRs。  
DBMS从DPT中包含的最小recLSN对应的日志记录开始扫描。对于每个

更新日志记录或CLR，如果符合条件，DBMS会重新应用更新。

#### 撤销阶段
在最后阶段，DBMS撤销崩溃时未提交的所有事务。DBMS按逆LSN顺序处理事务，使用lastLSN加速遍历。每次选择ATT中具有最大lastLSN的事务，撤销其更新。

当最后一个事务成功中止后，DBMS刷新日志，并准备处理新的事务。