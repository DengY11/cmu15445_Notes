# CMU15445 10
# 排序与聚合算法 (Sorting & Aggregation Algorithms)
## 1. 查询计划
DBMS将SQL编译成查询计划，这些查询计划是由操作符组成的**树状结构**。在面向磁盘的数据库系统中，我们使用缓冲池来实现需要**溢出到磁盘**(disk spilling,即将内存中的部分数据暂存在磁盘中)的算法，以最小化算法的I/O操作。
<img src="./10 pictrue/1.png" alt="图片描述" width="600" height="300">
## 2. 排序
DBMS需要对数据进行排序，因为在关系模型下，表中的元组没有特定顺序。排序在ORDER BY、GROUP BY、JOIN和DISTINCT操作符中可能会用到。如果需要排序的数据可以全部放入内存，那么DBMS可以使用**内存排序算法**（如快速排序）。如果数据**无法全部放入内存**，DBMS则需要使用能够根据需要溢出到磁盘的**外部排序算法**，优先选择**顺序I/O**而非随机I/O。

### 2.1 Top-N 堆排序
如果查询包含ORDER BY并带有LIMIT，DBMS只需扫描数据一次，以找到前N个元素，这称为**Top-N堆排序**。Top-N 堆排序利用一个**小根堆**（或**大根堆**，取决于是求最大的N个还是最小的N个值）来维护当前扫描过的数据中的前N个**最大**（或**最小**）元素。
- 开始时，堆是空的。随着数据的读入，我们将元素添加到堆中。
- 当堆中的元素数量达到N时，堆就初始化完毕。
- 继续读取数据中的每个新元素。
- 对于每个新元素，首先与**堆顶**元素（堆中的最小值）进行**比较**。
- 如果新元素大于堆顶元素（**这表明它比至少一个已存储的前N大元素要大**），执行以下步骤：
    - 从堆中移除堆顶元素。
    - 将新元素添加到堆中。
    - 调整以维护堆的性质

始终保持堆的**大小为N**。这意味着，一旦堆被填满，每当添加一个新元素，都必须移除当前的堆顶元素。当所有数据都被扫描完毕后，堆中将包含所有数据中的前N大（或小）元素。
<img src="./10 pictrue/2.png" alt="图片描述" width="600" height="300">



### 2.2 外部并归排序
标准的排序算法是外部合并排序。这是一种**分治**排序算法，将数据集分割成独立的**小区段**并分别排序。它可以根据需要将区段**溢出到磁盘**，然后一次读取一个。该算法由两个阶段组成：
- **阶段#1** – **排序**：首先，算法对可以放入主存的小块数据进行排序，然后将排序后的页面写回磁盘。
- **阶段#2** – **合并**：然后，算法将排序后的子文件合并为一个更大的单一文件。
排序的区段可以是提前物化的，这意味着值存储在页面中，也可以是晚物化(定义前面几节课讲过了，不多赘述)的，只存储记录ID并在稍后读取。

### 2.3 二路并归排序
最基本的版本是**二路合并排序**。在排序阶段，算法读取每个页面，进行排序，然后将排序后的版本写回磁盘。在合并阶段，它使用**三个缓冲页面**。从磁盘中读取两个已排序页面，并将它们合并到第三个缓冲页面。每当第三页填满时，它就被写回磁盘并替换为**空页**。每一组排序的页面称为一次运行，然后算法递归地将这些运行合并在一起。
  
  - 假设我们有一个数据集[8, 4, 7, 3, 2, 6, 5, 1]，内存一次只能容纳4个数据元素。
  - 划分阶段：

    - 将数据集分为两个子块 [8, 4, 7, 3] 和 [2, 6, 5, 1]。
    -  对每个子块进行排序：
    -  第一个子块排序为 [3, 4, 7, 8]
     - 第二个子块排序为 [1, 2, 5, 6]
     - 得到两个排序后的子文件 [3, 4, 7, 8] 和 [1, 2, 5, 6]
  - 合并阶段：

    - 将两个有序子文件 [3, 4, 7, 8] 和 [1, 2, 5, 6] 进行二路归并：
    - 结果是 [1, 2, 3, 4, 5, 6, 7, 8]
<img src="./10 pictrue/3.png" alt="图片描述" width="600" height="300">
### 2.4 通用（K路）并归排序
这个算法的通用版本允许DBMS利用**超过三个缓冲页面**。设B为可用缓冲页面总数，算法在排序阶段一次可以读取B页，并将⌈N/B⌉个排序后的运行写回磁盘。合并阶段也可以在每次遍历中合并最多B−1个运行，使用一个缓冲页面来存储合并数据并根据需要写回磁盘。

在通用版本中，算法执行**1 + ⌈log(B−1)⌉(N/B)次遍历**（一次排序阶段和⌈log(B−1)⌉(N/B)次合并阶段）。总I/O成本是**2N ×（遍历次数）**，因为它需要对每个页面进行读写操作。

## 3. 聚合
查询计划中的聚合操作符将**一个或多个元组**的值**合并为一个标量值**。实现聚合有两种方法：**（1）排序和（2）哈希**。

### 3.1 排序
DBMS首先根据GROUP BY键对元组进行排序。如果数据全部适合缓冲池，可以使用**内存排序算法**（如快速排序），否则使用**外部并归排序算法**。然后，DBMS对排序后的数据进行顺序扫描以计算聚合。操作符的输出将在键上排序。

进行排序聚合时，重要的是要**优化查询操作的顺序**以提高效率。例如，如果查询需要过滤，最好**先执行过滤**，然后对过滤后的数据进行排序，以减少需要排序的数据量。

### 3.2 哈希
哈希在计算聚合时可能比排序更“便宜”。DBMS在扫描表时填充一个临时哈希表。对于每条记录，检查哈希表中是否已有条目，并进行适当的修改。如果哈希表的大小**过大**而无法适应内存，则DBMS必须将其溢出到磁盘。完成此操作有两个阶段：

- **阶段#1 – 分区**：使用哈希函数h1将元组划分为基于目标哈希键的磁盘分区。所有匹配的元组将放入同一分区。假设总共有B个缓冲区，我们将有B-1个用于分区的输出缓冲区和1个用于输入数据的缓冲区。如果任何分区已满，DBMS会将其溢出到磁盘。

- **阶段#2 – 重新哈希**：对于磁盘上的每个分区，将其页面读入内存，并基于第二个哈希函数h2（h1 ≠ h2）构建一个内存中哈希表。然后遍历该哈希表的每个桶，以聚集匹配的元组以计算聚合。假设每个分区都适合内存。
<img src="./10 pictrue/4.png" alt="图片描述" width="600" height="300">

在重新哈希阶段，DBMS可以存储形式为**GroupByKey→RunningValue**的对来计算聚合。RunningValue的内容取决于聚合函数。要将新元组插入哈希表：

- 如果找到匹配的GroupByKey，则适当更新RunningValue。
- 否则插入一个新的(GroupByKey→RunningValue)对。

总的来说，对于聚合，除非数据已经预先排序（如Order By之后），否则哈希通常效率更高。