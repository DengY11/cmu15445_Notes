# CMU15445 17

## 时间戳排序并发控制
### 1. 时间戳排序并发控制 (Timestamp Ordering Concurrency Control)

**时间戳排序 (T/O)** 是一种乐观并发控制协议，假设事务冲突很少发生。在这种方法中，DBMS不要求事务在读写数据库对象前先获取锁，而是通过时间戳来确定事务的可串行化顺序。

每个事务 \( T_i \) 会分配一个唯一的、递增的时间戳 \( TS(T_i) \)。不同的方案会在事务执行的不同时间点分配时间戳，有些高级方案甚至会给一个事务分配多个时间戳。

**如果 \( TS(T_i) < TS(T_j) \)，则 DBMS 必须确保执行的事务顺序等同于串行化顺序，即 \( T_i \) 出现在 \( T_j \) 之前**。

时间戳的分配有多种实现策略。DBMS 可以使用系统时钟作为时间戳，但可能会遇到如夏令时之类的边缘情况问题。另一种选择是使用逻辑计数器，但这种方式在分布式系统中会遇到溢出和计数器维护问题。还有一些混合方法结合了两种方式的优点。

### 2. 基本时间戳排序 (BASIC T/O)

基本时间戳排序协议允许对数据库对象进行读写操作，而不需要使用锁。每个数据库对象 \( X \) 都标记有最近一次成功进行读取（记为 \( R-TS(X) \)）或写入（记为 \( W-TS(X) \)）操作的事务的时间戳。DBMS 对每个操作都会检查这些时间戳。如果某个事务尝试访问对象的方式违反了时间戳排序规则，事务将被中止并重新启动。这个协议的假设是冲突会很少，因此重启操作也会很少。

**在 时间戳排序协议中，事务不一定是按时间顺序执行的，但执行结果必须等效于按照时间戳顺序串行化的结果**。也就是说，事务执行的顺序必须符合分配给它们的时间戳顺序。

#### 读取操作
对于读取操作，如果 \( TS(T_i) < W-TS(X) \)，则违反了时间戳顺序（即不希望读取未来的修改），此时 \( T_i \) 将被中止并重新启动，分配一个新的时间戳。否则，读取操作是合法的，允许 \( T_i \) 读取 \( X \)。然后，DBMS 会将 \( R-TS(X) \) 更新为 \( R-TS(X) \) 和 \( TS(T_i) \) 中的较大值。此外，还需要在事务的私有工作区中保存 \( X \) 的本地副本，以确保可重复读。

<img src="./17 pictrue/1.png" alt="" width="600" height="350">

--------------------------------------------------------------------------------

##### 例子
假设我们有一个数据库，其中包含一个对象 \( X \)，并且有两个事务 \( T_1 \) 和 \( T_2 \) 正在并发运行。
##### 场景：
- 事务 \( T_1 \) 的时间戳 \( TS(T_1) = 10 \)。
- 事务 \( T_2 \) 的时间戳 \( TS(T_2) = 15 \)。
- 数据库对象 \( X \) 有一个最后写入时间戳 \( W-TS(X) = 12 \)，表示最近一次对 \( X \) 的写入是由时间戳为 12 的事务完成的。
- 数据库对象 \( X \) 的最后读取时间戳 \( R-TS(X) = 8 \)，表示最近一次读取操作是由时间戳为 8 的事务完成的。

##### 1. \( T_1 \) 尝试读取对象 \( X \)：
- \( T_1 \) 的时间戳为 10，且对象 \( X \) 的最后写入时间戳为 12（\( W-TS(X) = 12 \)）。
- 根据时间戳排序规则，如果事务 \( T_1 \) 试图读取 \( X \)，DBMS 会检查：
  - \( TS(T_1) < W-TS(X) \)，即 10 < 12。
  - 这意味着 \( T_1 \) 试图读取的数据 \( X \) 在未来被写入过（由时间戳为 12 的事务写入），因此这是一个无效的读取操作。
  
**操作结果**：由于 \( T_1 \) 的读取违反了时间戳排序，DBMS 会中止并重新启动 \( T_1 \) 给它分配一个新的时间戳。

##### 2. \( T_2 \) 尝试读取对象 \( X \)：
- \( T_2 \) 的时间戳为 15，且对象 \( X \) 的最后写入时间戳为 12（\( W-TS(X) = 12 \)）。
- DBMS 会检查：
  - \( TS(T_2) < W-TS(X) \)，即 15 < 12。
  - 显然，15 大于 12，这意味着 \( T_2 \) 读取的数据是有效的，因为它不会读取未来的数据。
  
- **操作结果**：事务 \( T_2 \) 可以成功读取对象 \( X \)。DBMS 还会更新 \( R-TS(X) \) 为 \( max(R-TS(X), TS(T_2)) \)，即 \( R-TS(X) = max(8, 15) = 15 \)。



--------------------------------------------------------------------------

#### 写入操作
对于写入操作，如果 \( TS(T_i) < R-TS(X) \) 或 \( TS(T_i) < W-TS(X) \)，则 \( T_i \) 必须重新启动（即不希望覆盖“未来”的修改）。否则，DBMS 允许 \( T_i \) 写入 \( X \)，并更新 \( W-TS(X) \)。同样，它需要在事务的本地工作区中保存 \( X \) 的副本，以确保可重复读。

<img src="./17 pictrue/2.png" alt="" width="600" height="350">

#### 优化：Thomas 写入规则
一种优化方案是，如果 \( TS(T_i) < W-TS(X) \)，DBMS 可以忽略该写入操作，允许事务继续执行，而不是中止并重启它。这称为 **Thomas 写入规则**。这种情况违反了时间戳排序规则，但可以接受，因为没有其他事务会读取 \( T_i \) 对对象 \( X \) 的写入。如果事务 \( T_i \) 后续读取对象 \( X \)，它可以读取自己工作区中的本地副本。

<img src="./17 pictrue/3.png" alt="" width="600" height="350">

**基本时间戳排序协议** 生成的调度是冲突可串行化的（如果不使用 Thomas 写入规则）。它不会产生死锁，因为没有事务需要等待。然而，长时间运行的事务更有可能因为读取了更新的对象而被饿死。此外，它允许生成不可恢复的调度（即如果某个事务读取了其他未提交的事务的数据，且该事务最终回滚，会导致不可恢复的情况）。

**潜在问题**：
- 每次读取对象都需要更新时间戳。
- 在事务的工作区中复制数据和更新时间戳的开销较大。
- 长时间运行的事务可能被饿死。
- 在高并发系统中，时间戳分配可能成为瓶颈。
- 允许不可恢复的调度。

------------------------------------------------------------------------------

#### 写入例子：
- 事务 \( T_1 \) 的时间戳 \( TS(T_1) = 20 \)。
- 事务 \( T_2 \) 的时间戳 \( TS(T_2) = 25 \)。
- 数据库对象 \( X \) 的当前值是 100。
- 对象 \( X \) 的最后读取时间戳 \( R-TS(X) = 15 \)，最后写入时间戳 \( W-TS(X) = 18 \)。

##### 写入操作示例：

##### 1. \( T_1 \) 尝试写入对象 \( X \)：
- \( T_1 \) 想将 \( X \) 的值更新为 110（将 100 修改为 110）。
- DBMS 在执行写入前，会检查：
  - **条件 1**：\( TS(T_1) < R-TS(X) \)，即 20 < 15。这是假的，20 大于 15，因此条件 1 不成立。
  - **条件 2**：\( TS(T_1) < W-TS(X) \)，即 20 < 18。这也是假的，20 大于 18，因此条件 2 不成立。

- 因为 \( T_1 \) 满足写入条件（既没有违反读写时间戳），因此 DBMS 允许 \( T_1 \) 执行写入操作，将对象 \( X \) 的值从 100 更新为 110。
- **操作结果**：
  - \( T_1 \) 成功写入 \( X = 110 \)。
  - DBMS 会将 \( W-TS(X) \) 更新为 \( TS(T_1) \)，即 \( W-TS(X) = 20 \)。

##### 2. \( T_2 \) 尝试写入对象 \( X \)：
- \( T_2 \) 想将 \( X \) 的值更新为 120。
- 现在对象 \( X \) 的最后写入时间戳是 \( W-TS(X) = 20 \)，最后读取时间戳是 \( R-TS(X) = 15 \)。
- DBMS 检查 \( T_2 \) 的写入条件：
  - **条件 1**：\( TS(T_2) < R-TS(X) \)，即 25 < 15。这是假的，25 大于 15，因此条件 1 不成立。
  - **条件 2**：\( TS(T_2) < W-TS(X) \)，即 25 < 20。这也是假的，25 大于 20，因此条件 2 不成立。

- 因为 \( T_2 \) 也没有违反任何时间戳规则，DBMS 允许 \( T_2 \) 执行写入操作，将对象 \( X \) 的值从 110 更新为 120。
- **操作结果**：
  - \( T_2 \) 成功写入 \( X = 120 \)。
  - DBMS 将 \( W-TS(X) \) 更新为 \( TS(T_2) \)，即 \( W-TS(X) = 25 \)。


------------------------------------------------------------------------------

### 3. 乐观并发控制 (Optimistic Concurrency Control, OCC)

<img src="./17 pictrue/4.png" alt="" width="600" height="350">

**乐观并发控制 (OCC)** 是另一种使用时间戳来验证事务的乐观并发控制协议。OCC 在冲突较少时表现最佳，例如当所有事务都是只读操作，或者事务访问的是不相交的数据集。如果数据库较大且负载均匀，冲突的概率较低，OCC 是一个不错的选择。

在 OCC 中，DBMS 为每个事务创建一个**私有工作区**。所有修改都在这个工作区中进行。读取的对象会被复制到工作区中，写入的对象也会在工作区中修改。其他事务无法读取这个事务在其工作区中做出的修改。

**当事务提交时，DBMS 会比较事务工作区的写入集合，以查看是否与其他事务发生冲突。如果没有冲突，写入集合会被应用到“全局”数据库中。**

OCC 包含三个阶段：
1. **读取阶段**：DBMS 跟踪事务的读/写集合，并将它们的写入操作存储在私有工作区中。
2. **验证阶段**：当事务提交时，DBMS 检查它是否与其他事务冲突。
3. **写入阶段**：如果验证成功，DBMS 将工作区的更改应用到数据库中，否则它会中止并重新启动事务。

#### 验证阶段
DBMS 在事务进入验证阶段时为其分配时间戳。为了确保只允许可串行化的调度，DBMS 会检查事务之间的读写冲突，确保所有冲突都朝着一个方向发展。

**验证方法**：
- **方法 1**：向后验证（从较新的事务向较旧的事务验证）
- **方法 2**：向前验证（从较旧的事务向较新的事务验证）

在**向前验证**中，DBMS 会检查提交事务的时间戳顺序与所有其他正在运行的事务之间的关系。尚未进入验证阶段的事务会被分配一个无限大的时间戳。

如果 \( TS(T_i) < TS(T_j) \)，则必须满足以下三个条件之一：
1. \( T_i \) 在 \( T_j \) 开始执行前完成所有三个阶段（串行顺序）。
2. \( T_i \) 在 \( T_j \) 的写入阶段之前完成，并且 \( T_i \) 不会写入 \( T_j \) 读取的任何对象。
   - \( WriteSet(T_i) \cap ReadSet(T_j) = \varnothing \)
3. \( T_i \) 在 \( T_j \) 完成读取阶段之前完成，并且 \( T_i \) 不会写入 \( T_j \) 读取或写入的任何对象。
   - \( WriteSet(T_i) \cap ReadSet(T_j) = \varnothing \) 且 \( WriteSet(T_i) \cap WriteSet(T_j) = \varnothing \)

<img src="./17 pictrue/5.png" alt="" width="600" height="350">

**潜在问题**：
- 将数据复制到事务的私有工作区的开销很大。
- 验证/写入阶段可能成为瓶颈。
- 事务在执行完成后才被中止，可能会浪费更多的资源。
- 时间戳分配会成为瓶颈。

### 4. 动态数据库与幻影问题

之前的讨论中，我们假设事务仅操作数据库中的静态对象。然而，当事务涉及插入、更新和删除操作时，会遇到新的问题。

**幻影问题** 出现在事务只锁定了已存在的记录，却忽略了正在被创建的记录。这可能导致非可串行化的执行，因为数据库中的对象集合不是固定的。

**解决幻影问题的方案**：
1. **重新执行扫描**：事务在提交时重新运行查询，检查结果是否不同，确认是否遗漏了新的或删除的记录。
2. **谓词锁定**：基于查询的谓词获取锁，确保符合谓词条件的任何数据都不能被其他事务修改。
3. **索引锁定**：利用索引键来保护数据范围，防止新数据落入锁定的范围内。

### 5. 隔离级别

**隔离级别** 控制事务在多事务环境中暴露于其他并发事务的操作程度。它们从最严格的**可串行化**到最弱的**读未提交**依次减弱。可串行化保证了最高的一致性，但限制了并行性。