# CMU15445 04
## 数据库内存管理的劣势与优化
### 插槽式内存页的劣势
- **内存碎片化**：当删除某些元组(**tuple**)后，插槽的空闲空间不能被及时重用，导致内存碎片化。
- **多页读取**：如果有20个元组分别储存在20个不同的页上，那么读取20个元组就要访问20个页，增加了**I/O**开销。
### RocksDB等数据库的优化：日志结构内存页
为了避免这些问题，RocksDB采用了**日志结构内存页(Log-structured In-Memory Pages)**。
- **日志记录**：日志结构内存页不储存完整的元组，而是储存元组的变更记录。
    - 如图所示，内存页中记录了对元组的**PUT**和**DEL**操作。
    <img src="./04 pictrue/1.png" alt="图片描述" width="250" height="300">
- **写满写入硬盘**：当一个内存页写满后，会将其写入硬盘。这样一来，修改20个元组只需要写在一张内存页上，不会像插槽式内存页那样产生**随机访问**问题(*最坏情况20个元组储存在20张页，访问修改需要读取20张页*)。
### 优缺点对比
 - **优点**：日志结构内存页减少了随机访问，加快了写入速度。
 - **缺点**：虽然写入速度提高了，但读取速度可能会变慢。当需要读取特定的元组，如id = 104时，需要扫描整张内存页，如果数据不在内存中，还需要访问硬盘。
<img src="./04 pictrue/2.png" alt="图片描述" width="350" height="250">
### 读取数据的优化
- **索引结构**：为了提高读取效率，数据库使用索引结构如**B+数**，**Trie**，**跳表**等，来维护元组的位置索引。
    - 索引结构可以快速定位元组是否在内存页或在磁盘中的具体位置。
### 存储操作
数据库往往不需要存储所有的老的日志数据，以减少空间浪费。
- 如图所示，最终只存储了'id = 103','id = 104','id = 105' 最后确认的数据。
![](./04%20pictrue/3.png)
- 同时，如果高层指令移除了'id = 102', 'id = 103' 的数据，就没有必要再存储102 和103的old log，访问时只需要返回key不存在。
- 最后，我们会按照key关键字**排序**，因为数据的顺序并不是我们所关心的。

### 两种压缩方式
- 1.**全局压缩**（Universal Compaction）：
    将磁盘上相邻的已排序的日志文件进行合并。
- 2.**层次压缩**（Level Compaction）：
这是LevelDB名字的由来。在第0层，不断添加更多已排序的文件，直到某个时刻触发阈值进行压缩操作。在下一层将它们**合并**成一个更大的文件。如果更大的文件也触发条件，继续合并更大的文件，即压缩层次更低的文件**联级下降**合并为层次更高的文件。
### 索引组织存储/索引组织表（Index Organized Storage/Index Organized Tables）
- 与其让叶子节点携带指向记录ID的值，这些ID指示我们去哪里找到包含所需数据的页，不如让叶子节点本身包含数据的页。
    - 这是MySQL InnoDB引擎的方式。页看起来像是插槽架构，其中key和offset在一个方向增长，而元组ID（tuple ID）则在另一个方向上增长。

![](./04%20pictrue/4.png)

此外，还有ISAM等存储方式，但已经过时，无需关注。
### 元组（Tuple）概念
- 元组可以理解为一个char数组。注意要解决**内存对齐**等问题，可以用填充000000数据或对数据**排序**来解决。
- 页的大小是固定的，由数据库系统决定。所以对于很长的数据或**可变长数据**，数据库并不会直接将数据存储在元组页上，而是在**溢出页（overflow page）**，原本的页只存储指向溢出页上数据的指针。
![](./04%20pictrue/5.png)