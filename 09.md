# CMU15445 09 
# B+树并发控制
我们可以直接对整棵加一把大锁来实现线程安全，但这样和单线程就没有区别了。为了减少锁的**粒度**，可以使用一些机制。
- **螃蟹锁**（Crab Latching）是一种在处理并发修改时常用的技术，尤其在需要遍历和修改树形数据结构（如B+树）时。它通过逐步加锁和解锁的方式，在保证数据一致性的同时，尽量减少锁的持有时间，以提高并发性能。
- 某些情况下，可能使用**乐观锁**（Optimistic Concurrency Control, OCC），即在进行操作之前不加锁，操作完成后再进行验证。如果验证失败（如数据被其他线程修改过），则回滚并重试操作。

## 1. 读取操作中的螃蟹锁机制
在读取操作中，螃蟹锁的主要目标是确保读取的数据在读取过程中不会被修改，同时最大限度地减少锁的持有时间。具体过程如下：

- **逐步加锁**：读取操作从树的根节点开始。首先对根节点加锁（通常是读锁），然后读取节点中的数据，确定下一步需要访问的子节点。

- **向下遍历**：根据需要访问的子节点信息，对子节点加锁后，立即释放父节点的锁。这样，只有当前正在访问的节点保持锁定状态，减少了锁的持有时间和范围。

- **到达叶子节点**：这个过程会一直重复，直到访问到目标叶子节点。在叶子节点中读取到需要的数据。

- **返回数据**：一旦数据读取完成，立即释放叶子节点的锁。

这种逐步加锁和解锁的方式确保了读取过程中每一步的数据都是一致的，并且在读取完成之前，尽量少地持有不必要的锁。

## 2. 修改操作中的螃蟹锁机制
修改操作（如插入、删除）需要在读取的基础上进行更复杂的锁管理。螃蟹锁通过合理的锁定和解锁策略，确保在并发环境下进行安全修改：

- **逐步加锁**：和读取操作类似，修改操作也是从根节点开始逐步向下加锁。不同的是，修改操作通常需要写锁，因为要对节点进行更新。

- **安全状态判断**：在访问每个节点时，判断是否可以在不进一步分裂或合并的情况下完成修改。如果可以，意味着这个节点处于**安全状态**，之后的修改都不会影响父节及往上的节点，那么可以释放之前的父节点的锁。
    - **节点空间的检查**：当我们遍历到某个节点时，如果当前节点在插入一个新的键值对后仍然不会超过这个容量（即不需要分裂），那么可以认为这个节点是安全的，不会触发上层父节点的修改。
    - **提前判断分裂可能性**：如果当前节点的空间已经接近满了，那么在实际执行插入之前，我们可以判断出插入操作很可能会导致节点分裂。在这种情况下，必须继续持有父节点的锁。

- **锁的释放**：当确定不再需要修改父节点时，立即释放父节点的锁。只有当前正在操作的节点保持锁定，减少锁的范围。

- **处理冲突**：如果在操作过程中发现当前节点的操作（如插入）可能导致节点分裂，则需要持有更多的锁来安全地完成分裂操作。通常，在分裂操作完成并且安全后，逐步释放不再需要的锁。

- **递归处理父节点**：如果当前节点发生了分裂或合并，可能需要对父节点进行更新。这时，将继续向上层的父节点请求锁，并重复前述的步骤。

## 3.我的具体代码实现：
###  插入操作的实现思路
- **从根到叶的逐步锁定**：
  - 插入操作首先通过调用InsertGetKeyAt方法，从根节点开始逐层向下寻找合适的叶子节点。每次到达一个新的节点时，都会获取该节点的写锁，**同时根据节点的状态决定是否可以释放父节点的锁**​​。
- **判断节点是否需要分裂**：
  - 在叶子节点进行插入时，如果节点已经满了，会触发节点的分裂操作。这时需要将分裂后的新节点插入到父节点中​​。
- **处理节点分裂**：
  - 如果插入导致叶子节点的分裂，则新创建的节点及其对应的中间键值会插入到父节点中。如果父节点也因此满了，分裂操作会继续向上递归，直到调整完毕或新创建一个根节点​​。
- **释放机制**：
  - 在遍历过程中，代码会检查当前节点是否能**安全地完成插入操作**（即插入后不会触发分裂），如果可以，之前的父节点锁将被释放。
### 删除操作的实现思路
删除操作比插入更复杂，因为删除可能导致节点的合并或从兄弟节点借用键值。

- **从根到叶的逐步锁定**：
  - 删除操作通过调用DeleteGetKeyAt方法，从根节点开始逐层向下寻找目标叶子节点。每层节点在访问时都会加写锁，并根据节点的状态决定是否可以释放**父节点的锁**​​。
- **判断节点是否需要合并或借用**：
在叶子节点删除键值对后，如果节点的大小低于最小容量，会尝试从兄弟节点借用键值或与兄弟节点合并​​。
- **处理节点合并和借用**：
  - 如果叶子节点的大小不足以维持其结构，且不能从兄弟节点借用，则会触发节点合并操作。合并操作同样可能需要对父节点进行调整，这会导致对父节点的进一步锁定和修改​​。
- **安全判定机制**：
  - 在删除过程中，代码会在每个节点上判断是否可以安全地完成删除操作（即删除后不会导致节点大小低于最小容量），如果可以，之前的父节点锁将被释放​​。