# CMU15445 11

## 查询处理2

### 背景
在之前的讨论中，我们假设查询是由**单一工作线程**执行的。然而在实际应用中，查询通常是由多个工作线程**并行执行**的。

并行执行对DBMS有以下几个关键好处：

**提高吞吐量**（每秒查询次数增加）和**降低延迟**（每个查询耗时减少）。
提高DBMS对外部客户端的响应速度和可用性。
潜在降低**总体拥有成本**（TCO），包括硬件采购、软件许可、部署DBMS的人工成本以及运行机器所需的能源。
DBMS支持两种类型的并行性：**查询间并行性**（inter-query parallelism）和**查询内并行性**（intra-query parallelism）。

### 并行数据库 vs 分布式数据库
在**并行**和**分布式**系统中，数据库被分布在多个“资源”上以提高并行性。这些资源可能是计算资源（例如CPU核、CPU插槽、GPU、额外的机器）或存储资源（例如磁盘、内存）。

重要的是要**区分**并行系统和分布式系统：

- **并行DBMS**：在并行DBMS中，资源或节点物理上彼此**靠近**。它们通过高速互连通信，通信不仅速度快，而且成本低且可靠。

- **分布式DBMS**：在分布式DBMS中，资源可能**相距甚远**，数据库可能跨越不同地区的机架或数据中心。因此，资源通过较慢的互连（通常是公共网络）进行通信。节点之间的通信成本更高，且故障不能忽略。

尽管数据库可能在多个资源上物理分布，但对应用来说，它仍然表现为单一的逻辑数据库实例。因此，在单节点DBMS上执行的SQL查询应该在并行或分布式DBMS上**生成相同的结果**。

### 进程模型
DBMS的进程模型定义了系统如何支持来自多用户应用环境的并发请求。DBMS由**一个或多个工作线程组成**，这些线程负责执行客户端的任务并返回结果。应用程序可能发送大量请求或同时发送多个请求，这些请求必须被分配给不同的工作线程。
<img src="./13 pictrue/1.png" alt="" width="600" height="250">

#### 每工作线程一个进程模型(Process per Worker)
最基本的方法是每工作线程对应一个操作系统进程，这样依赖于**操作系统调度**。应用程序发送请求并打开与数据库系统的连接。某个调度器接收到请求并选择一个工作进程来管理连接。之后，应用程序与负责执行该请求的工作进程直接通信。

这种模型的优势在于，如果某个进程崩溃，**整个系统不会受到影响**，因为每个工作线程在自己独立的操作系统进程中运行。然而，这种方法依赖共享内存来维护全局数据结构，或依赖消息传递，这会**增加开销**。

一些使用这种模型的系统包括IBM DB2、Postgres和Oracle。

#### 每工作线程一个线程模型(Thread per Worker)
当前最常见的模型是每工作线程对应一个线程，而不是不同进程来执行不同任务。每个数据库系统只有一个进程，**多线程在该进程中运行**，DBMS可以完全控制任务和线程的调度。

这种多线程架构的优势包括**上下文切换开销更少**，并且不需要维护一个共享模型。然而，线程崩溃可能导致**整个数据库进程的崩溃**。此外，这个模型并不一定意味着DBMS支持查询内并行性。

近20年来，几乎所有创建的DBMS都采用了这种方法，包括Microsoft SQL Server和MySQL。IBM DB2和Oracle也更新了它们的模型以支持这种方法，而Postgres及其衍生的数据库则主要仍然使用基于进程的模型。

#### 调度
总结来说，对于每个查询计划，DBMS需要决定在何处、何时以及如何执行。相关的问题包括：

- 应该使用多少个任务？
- 应该使用多少个CPU核心？
- 这些任务应该在哪些CPU核心上执行？
- 任务的输出应该存储在哪里？
- 在决定查询计划时，DBMS往往比操作系统（OS）更了解系统内部情况，因此在调度时应该优先考虑DBMS的决策，而不是OS的默认安排。

#### 嵌入式DBMS
一种完全不同的数据库使用模式是嵌入式DBMS，即**系统运行在与应用程序相同的地址空间中**，而不是像传统的客户端-服务器模型那样，数据库独立于应用程序。在这种情况下，应用程序将负责设置数据库系统的线程和任务，调度也由应用程序本身负责。
<img src="./13 pictrue/2.png" alt="" width="600" height="450">
目前，最著名的嵌入式DBMS包括 DuckDB、SQLite 和 RocksDB。这些系统通常被嵌入到应用程序内部，而不作为独立的服务器进程存在。

### 查询间并行性
在查询间并行性中，DBMS同时执行不同的查询。由于**多个工作线程同时运行请求**，整体性能得到提高，从而增加吞吐量并减少延迟。

**如果查询是只读的，则多个查询之间几乎不需要协调**。然而，如果多个查询同时更新数据库，则会出现更复杂的冲突问题。

### 查询内并行性
在查询内并行性中，DBMS**并行执行单个查询的操作**，从而减少长时间运行查询的延迟。

查询内并行性的组织可以被理解为**生产者/消费者范式**。每个操作符**既是数据的生产者**，**也是从其他操作符（在其下方运行）消费数据的消费者**。对于每个关系操作符，都存在并行算法。DBMS可以让多个线程访问集中式数据结构，或通过分区来划分工作。

#### 操作符内并行性（横向并行）
在操作符内并行性中，查询计划的操作符被分解为独立的片段，这些片段在不同的（不相交的）**数据子集**上执行相同的功能。DBMS在查询计划中插入交换操作符以**合并子操作符的结果**。交换操作符在接收到所有子操作符的数据之前，**阻止执行其上方的操作符**。
<img src="./13 pictrue/3.png" alt="" width="600" height="350">

#### 操作符间并行性（纵向并行）
在操作符间并行性中，DBMS重叠执行操作符，以在不同阶段之间无物化地传递数据。这通常被称为流水线并行性。
<img src="./13 pictrue/4.png" alt="" width="600" height="350">

#### Bushy 并行性
Bushy并行性是**操作符内并行性**和**操作符间并行性**的**混合体**，其中工作线程同时执行查询计划的不同段中的多个操作符。DBMS仍然使用交换操作符来合并这些段的中间结果。
<img src="./13 pictrue/5.png" alt="" width="600" height="350">

#### I/O 并行性
如果**磁盘始终是主要瓶颈**，那么使用额外的进程/线程来并行执行查询**不会提高性能**。因此，将数据库分布在多个存储设备上是很重要的。

#### 多磁盘并行性
在多磁盘并行性中，操作系统或硬件被配置为将DBMS的文件存储在多个存储设备上。这可以通过存储设备或RAID配置来完成。所有的存储设置对DBMS是透明的，因此工作线程无法在不同设备上操作，因为DBMS无法感知底层的并行性。

#### 数据库分区
在数据库分区中，数据库被分割为不相交的子集，这些子集可以分配给不同的磁盘。一些DBMS允许指定每个数据库的磁盘位置，这在文件系统级别很容易实现，尤其是当DBMS将每个数据库存储在一个独立的目录中时。通常，变更日志文件是共享的。

逻辑分区的理念是将单一逻辑表划分为不相交的物理段，这些段被单独存储和管理。理想情况下，这种分区对应用是透明的，即应用不需要关心数据是如何存储的，只需访问逻辑表即可。

这些方法将在学期后期讨论分布式数据库时进一步探讨。