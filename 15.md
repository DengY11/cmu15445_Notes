# CMU15445 14
## 并发控制理论 Concurrency Control Theory

### 1. 动机(Motivation)
- **丢失更新问题 (Concurrency Control)**: 如何避免在同时更新记录时出现竞态条件？
- **持久性问题 (Recovery)**: 在发生电源故障的情况下，如何确保数据库的正确状态？

### 2. 事务(Transactions)
**事务**是对共享数据库(shared database)执行一个或多个操作（例如SQL查询）以实现某种高级功能的执行过程。它们是DBMS中最基本的变更单元。 *Partial transactions are not allowed*,**部分事务是不允许的（即事务必须是原子的）**。

**示例:** 
- 将$100从Andy的银行账户转移到他的推广人账户
- 检查Andy是否有$100。
- 从他的账户中扣除$100。
- 将$100添加到他的推广人账户。
<img src="./15 pictrue/1.png" alt="" width="600" height="300">
**所有步骤要么全部完成，要么完全不执行。**

#### 简易系统( Strawman System)
处理事务的一个简单系统是使用**单个工作线程**（例如一个线程）一次执行一个事务。因此，每次只能运行一个事务。**为了执行事务，DBMS会复制整个数据库文件并将事务更改应用于此新文件**。**如果事务成功**，**新文件将成为当前数据库文件**；**如果事务失败，DBMS将丢弃新文件**，事务的任何更改都不会被保存。这种方法很**慢**，因为它不允许并发事务，并且每次事务都需要**复制整个数据库文件**。

一种（潜在）更好的方法是允许独立事务的并发执行，同时保持**正确性和公平性**（即所有事务被平等对待，不会因为一直得不到执行机会而“饥饿”）。但在DBMS中执行并发事务是有挑战性的。在确保正确性的同时快速执行事务是困难的（例如，如果Andy只有$100并试图同时支付给两个推广人，应该支付给谁？）。我们简单的示例保证了顺序正确性，但以并行性为代价。

**任意交错的操作**(Arbitrary interleaving of operations)可能导致：

- **暂时不一致**: 不可避免，但不是问题。
- **永久不一致**: 不可接受，会影响数据的正确性和完整性。

事务的作用范围仅限于数据库内部。它不能对外部世界进行更改，因为**无法回滚**。例如，如果一个事务导致发送电子邮件，DBMS在事务中止时无法撤销这一操作。

### 3. 定义
形式上，数据库可以表示为**一组固定的命名数据对象**（A, B, C, ...）。这些对象可以是属性、元组、页面、表甚至整个数据库。我们将讨论的算法适用于任何类型的对象，但所有对象必须是相同类型的。

**一个事务是对这些对象进行的一系列读和写操作**（例如，R(A), W(B)）。
*为简化讨论，这个定义假设数据库大小是固定的，因此操作只能是读取和更新，而不是插入或删除*。

**事务的边界由客户端定义**。在SQL中，事务以BEGIN命令开始。事务的结果要么是COMMIT（提交）要么是ABORT（中止）。对于COMMIT，要么所有事务的修改都保存到数据库中，要么DBMS覆盖它并改为中止。对于ABORT，事务的所有更改都将被撤销，使其看起来像事务从未发生过一样。中止可以是自我引发的，也可以由DBMS引起。

用于确保数据库正确性的标准由ACID首字母缩写给出：
<img src="./15 pictrue/2.png" alt="" width="600" height="300">
- **原子性 (Atomicity)**: 确保事务中的所有操作要么全部发生，要么都不发生。
- **一致性 (Consistency)**: 如果每个事务都是一致的，并且数据库在事务开始时是一致的，那么当事务完成时，数据库也将是一致的。数据是一致的，如果它满足所有验证规则，如约束、级联和触发器。
- **隔离性 (Isolation)**: 当事务执行时，它应该有被隔离的错觉。隔离确保并发执行的事务与事务的顺序执行具有相同的最终数据库状态。
- **持久性 (Durability)**: 如果事务提交，那么它对数据库的影响应该是持久的。


### 4. ACID: 原子性
DBMS保证事务是原子的。事务要么执行其所有操作，要么完全不执行。有两种实现方法：

- #### 方法1：日志记录 (Logging)
    DBMS记录所有操作，以便在事务中止时撤销这些操作。它在内存和磁盘上维护撤销记录。日志记录被几乎所有现代系统用于审计和效率原因。
    <img src="./15 pictrue/4.png" alt="" width="600" height="300">

- #### 方法2：影子分页 (Shadow Paging)
    DBMS制作事务修改过的页面的副本，事务对这些副本进行更改。**只有当事务提交时，页面才变得可见**。这种方法在运行时通常比基于日志的DBMS慢。然而，如果只使用单线程，则不需要日志记录，因此在事务修改数据库时写入磁盘的次数减少。这也简化了恢复过程，因为只需删除未提交事务的所有页面即可。但通常，更好的运行时性能比更好的恢复性能更重要，因此这种方法在实际中很少使用。
    <img src="./15 pictrue/5.png" alt="" width="600" height="300">

### 5. ACID: 一致性
从高层次来看，一致性意味着数据库所表示的“世界”是逻辑正确的。应用程序对数据的所有查询将返回逻辑上正确的结果。一致性有两个概念：

- #### 数据库一致性
    数据库准确地表示它所模拟的现实世界实体，并遵循完整性约束（例如，一个人的年龄不能为负）。此外，将来事务应看到过去提交的事务的效果。

- #### 事务一致性
    如果数据库在事务开始前是一致的，那么在事务结束后也将是一致的。确保事务一致性是应用程序的责任。

### 6. ACID: 隔离性
DBMS为事务提供它们在系统中独自运行的错觉。它们看不到并发事务的效果。这相当于一个事务按顺序执行的系统（即一次只执行一个事务）。但为了实现更好的性能，**DBMS必须在保持隔离性错觉的同时，交错执行并发事务的操作**。
<img src="./15 pictrue/3.png" alt="" width="600" height="600">
#### 并发控制 (Concurrency Control)
并发控制协议是DBMS在运行时决定多个事务的操作如何正确交错的方式。

有两类并发控制协议：
- **悲观 (Pessimistic)**: DBMS假设事务会发生冲突，因此不会让问题首先出现。
- **乐观 (Optimistic)**: DBMS假设事务间的冲突很少见，因此选择在事务提交后处理冲突。

DBMS执行操作的顺序称为执行计划。**我们希望交错事务以最大化并发性，同时确保输出是“正确的”。**

并发控制协议的目标是生成等价于某个顺序执行的执行计划：

- **顺序计划 (Serial Schedule)**: 不交错不同事务的操作的计划。
- **等价计划 (Equivalent Schedules)**: 对于任何数据库状态，如果执行第一个计划的效果与执行第二个计划的效果相同，则两个计划是等价的。
- **可串行化计划 (Serializable Schedule)**: 一个可串行化的计划是等价于事务的任何顺序执行的计划。不同的顺序执行可能产生不同的结果，但都被认为是“正确”的。

如果它们满足以下三个条件，则说两个操作**存在冲突**：
- 这两项业务都属于不同的事务。
- 两个操作都在同一个数据项上运行。
- 至少有一个操作是写操作。

**冲突有三种变体**：
- **读-写冲突**（Unrepeatable Reads）: 一个事务在多次读取同一个对象时无法得到相同的值。例如，事务T1读取数据A，随后事务T2修改A并提交，再次读取A时，T1看到的值与第一次读取的不同。
- **写-读冲突**（Dirty Reads）: 一个事务看到另一个事务未提交的更改。例如，事务T1修改数据A但未提交，事务T2读取了A的这个未提交值，随后T1回滚了更改，这就导致了数据不一致。
- **写-写冲突**（Lost Updates）: 一个事务覆盖了另一个并发事务的未提交数据。例如，事务T1和T2都修改数据A，T2的更改覆盖了T1的未提交更改，导致T1的更改丢失。

例子

- 示例 1：事务T1的操作W(X)和事务T2的操作R(X)是写-读冲突
- 示例 2：类似地，T1的操作W(X)和T2的W(X)是写- 写冲突
- 示例 3：T1的操作W(X)和T2的W(Y)是非冲突操作，因为两个写操作都不在同一数据项上工作，因此这些操作不满足第二个条件。
- 示例 4：类似地，T1的R(X)和T2的R(X)是非冲突操作，因为它们都不是写操作。
- 示例 5：类似地，T1的R(X)和T1的W(X)是非冲突操作，因为两个操作属于同一事务T1

串行化有两种类型：（1）**冲突串行化**和（2）**视图串行化**。两者都不允许所有被认为是可串行化的计划。在实际中，DBMS支持冲突串行化，因为它可以高效地实施。

#### 冲突串行化 (Conflict Serializability)
冲突串行化是指一个执行计划如果可以通过**交换非冲突的操作**，使其等价于某个顺序执行的计划，那么这个执行计划就是冲突可串行化的。换句话说，**一个计划是冲突可串行化的，当且仅当它的执行顺序可以调整，使得执行效果与某个顺序执行的计划相同**。

可以通过交换非冲突操作直到形成一个顺序计划来验证一个计划是否是冲突可串行化的。对于有许多事务的计划，这变得过于昂贵。可以使用**依赖图**（又称为优先图）来验证一个执行计划是否**是冲突可串行化的**：

- 在依赖图中，每个事务是一个节点。
- 如果在计划中，事务Ti的操作Oi与事务Tj的操作Oj发生冲突，并且Oi在Oj之前执行，那么在图中添加一条从Ti指向Tj的有向边。
- 如果这个图是无环的，则该执行计划是冲突可串行化的。
<img src="./15 pictrue/6.png" alt="" width="600" height="300">
无环的依赖图表明我们可以调整事务的执行顺序，使得它们的执行效果等价于某个顺序执行的计划。

#### 视图串行化 (View Serializability)
视图串行化是一个更弱的串行化概念，**它允许所有冲突可串行化和“盲写”**（即在不先读取值的情况下执行写操作）的计划。因此，它比冲突串行化允许更多的计划，但难以高效实施。这是因为DBMS不知道应用程序将如何“解释”值。因此，**视图串行化在实际中不常使用**。

##### 视图等价
两个计划被视为视图等价的当且仅当它们满足以下条件：
- **初始读等价**: 在两个计划中，一个计划读取了一个data item的初始值，另一个计划也必须读取这个data item的初始值
- **读操作等价**: 如果在一个计划里，一个操作是读了一个写操作后的值，另一个计划也必须读同样写操作后的值。
- **最终写等价**: 在两个计划中，一个计划写入了一个data item的值，另一个计划也必须写入这个data item的值

##### 关于“盲写”
视图串行化允许盲写，即一个事务可以直接写数据而不先读取它。这种操作在视图串行化中是允许的，因为最终数据库状态是正确的。例如，事务T1修改数据A，然后事务T2直接覆盖A的值，这种情况下即使T1的修改被“覆盖”，最终的数据库状态依然可以与某个顺序计划等价


#### 计划的范围
Serial Schedules ⊂ Conflict Serializable Schedules ⊂ View Serializable Schedules ⊂ All Schedules

### 7. ACID: 持久性
所有已提交事务的更改在崩溃或重启后必须是持久的。DBMS可以使用日志记录或影子分页来确保所有更改都是持久的。这通常要求已提交的事务存储在非易失性内存中。