# CMU15445 14
## 查询规划与优化：从逻辑到物理执行的最佳路径选择

### 概述
由于SQL是一种**声明式语言**，查询只描述了要计算什么，但并不说明如何计算。因此，DBMS需要将SQL语句转换为可执行的查询计划。

每个查询计划中的操作符都有多种执行方式（如不同的连接算法），不同的执行方式会带来性能差异。DBMS的优化器的任务就是为每个查询选择一个**最佳的执行计划**。

查询优化器的首次实现是1970年代的IBM System R。在此之前，人们普遍认为DBMS无法比人类更好地构建查询计划。如今，许多优化器的概念和设计决策仍源自System R。

查询优化有两种高层次的策略：

- **基于规则的优化（静态规则/启发式）**：这种方法通过已知的模式匹配查询的各个部分，以组装查询计划。这些规则通过转换查询来消除低效部分。
- **基于成本的优化**：通过读取数据并估计执行不同计划的代价，选择代价最低的执行计划。
虽然一些系统尝试通过机器学习来提高优化器的效率，但目前没有主流DBMS采用基于机器学习的优化器。

#### 逻辑计划 vs 物理计划
优化器的任务是**将逻辑代数表达式映射到等效的物理代数表达式**，以生成最佳的执行策略。逻辑计划大致对应于查询中的关系代数表达式，而物理操作符则定义了具体的执行策略，通常依赖于数据的物理存储格式（如排序、压缩等）。

逻辑计划与物理计划之间并不是一一对应的关系。

### 逻辑查询优化
<figure>
    <img src="./14 pictrue/1.png" alt="图片描述" width="600" height="400">
    <figcaption>
    <strong>SQL Query</strong>：应用程序发送SQL查询到数据库系统。该查询包含用户希望数据库系统执行的操作<br>
    <strong>SQL Rewriter (可选)</strong>：这是一个可选的步骤，SQL查询可能会被重写，以便更好地优化执行。这种情况很少见。<br>
    <strong>Parser (解析器)</strong>：SQL查询被传递给解析器，解析器会将查询解析成抽象语法树（Abstract Syntax Tree），这是查询的结构化表示。<br>
    <strong>Binder (绑定器)</strong>：绑定器使用数据库的系统目录，将语法树中的名称映射到内部的标识符（例如，将表名和列名与它们的内部ID关联）。它还可能进行一些检查，确保查询中的对象确实存在。<br>
    <strong>Tree Rewriter (可选)</strong>：另一个可选步骤，绑定后的逻辑计划可能会被进一步重写。这一步通常用来利用更多的表结构信息进行优化。<br>
    <strong>Optimizer (优化器)</strong>：优化器负责选择最优的执行计划。它会接收逻辑计划，并基于代价模型（Cost Model）对不同的执行计划进行估计，然后选择代价最小的计划。代价模型包括对CPU、内存、磁盘I/O、网络等资源的估计。<br>
    <strong>Physical Plan (物理执行计划)</strong>：最终，优化器生成物理执行计划，定义具体的执行方式（如选择何种连接算法、索引使用情况等）。这个物理计划将交给数据库引擎执行，完成查询。<br>
    <figcaption>
</figure>

一些**选择条件优化**的策略包括：
- **谓词下推**：尽可能早地执行过滤操作。
- **重新排序谓词**：让选择性最高的谓词先执行。
- **分解复杂谓词**：将复合谓词拆分，并将其下推。
<img src="./14 pictrue/2.png" alt="" width="600" height="300">

**投影(projection)优化**策略包括：
- **投影下推**：尽可能早地执行投影操作，减少中间结果的大小。
- **移除不需要的属性**：只保留查询需要的属性。
<img src="./14 pictrue/3.png" alt="" width="600" height="350">

**查询重写(query rewrite)优化**的策略包括：
- **移除不可能或不必要的谓词**，减少计算开销。
- **合并谓词**：简化冗余的谓词。
- **重写嵌套子查询**：通过去关联或展平嵌套查询。
- **分解复杂查询**：将复杂的嵌套查询拆分为多个部分，并将结果存储在临时表中。
<img src="./14 pictrue/4.png" alt="" width="600" height="250">
*合并谓词 —— 查询 1 中的 WHERE 谓词存在冗余，因为它在查询的实际上查找的是 1 到 150 之间的任意值。查询 2 展示了一种更简洁的表达方式，达到了查询 1 的相同目的。*
<figure>
    <div style="text-align: center;">
        <img src="./14 pictrue/5.png" alt="" width="375" height="250" >
    </div>
    <figcaption><i>图 5：子查询优化 - 重写：通过将子查询重写为 JOIN，前一个查询可以像后一个查询一样重新表达。通过这种方式移除嵌套级别，可以有效地将查询展平。</i><figcaption>
</figure>

<figure>
    <div style="text-align: center;">
        <img src="./14 pictrue/6.png" alt="" width="475" height="250" >
    </div>
    <figcaption><i>图 6：子查询优化 - 分解对于带有复杂子查询的查询，DBMS 优化器可以将原始查询分解为多个区块，并逐一优化每个区块。在这个示例中，优化器将包含嵌套聚合的查询拆分，将嵌套查询提取为独立查询，并利用该结果来实现原始查询的逻辑。</i><figcaption>
</figure>

<figure>
    <div style="text-align: center;">
        <img src="./14 pictrue/7.png" alt="" width="375" height="125" >
    </div>
    <figcaption><i>图 7:一个很浪费的查询的例子，join 算法是在这里是没有意义的</i><figcaption>
</figure>

**连接操作的顺序**是决定查询性能的**关键因素**。由于穷尽所有可能的连接顺序效率低下，因此优化连接顺序需要使用成本模型。

### 成本估计
DBMS使用成本模型来估算执行计划的代价。评估计划时，代价取决于多个物理和逻辑指标，包括：

- **CPU**：成本较低，但难以估计。
- **磁盘I/O**：块传输的数量。
- **内存**：使用的内存量。
- **网络**：发送的消息数量。

为了近似查询的成本，DBMS 在其内部目录中维护了关于表、属性和索引的内部**统计信息**。不同的系统以不同的方式维护这些统计数据。大多数系统尝试通过维护内部统计表来避免即时计算。这些内部表可能会在后台更新。

对于每个关系 \(R\)，DBMS 维护以下信息：
- \(N_R\)：关系 \(R\) 中的元组数量
- \(V(A, R)\)：属性 \(A\) 的不同值的数量

基于上述信息，优化器可以推导出**选择基数** \(SC(A, R)\) 统计量。选择基数是给定属性 \(A\) 的值后，平均返回的记录数，公式为 \( \frac{N_R}{V(A, R)} \)。需要注意的是，这假设数据是均匀分布的。这个假设经常不准确，但简化了优化过程。

### 选择性估计
**选择性（selectivity）指的是谓词满足的元组的比例**。DBMS可以通过计算谓词的选择性来**估计**符合条件的元组数量。对于复杂的谓词，如范围查询或合取谓词，选择性估计会更加复杂。

常见的假设包括：

- **数据均匀性**：除少数特殊值外，数据分布均匀。
- **谓词独立性**：不同属性上的谓词是独立的。
- **包含原则**：连接键的域重叠，即内表中的每个键都存在于外表中。
<figure>
    <div style="text-align: center;">
        <img src="./14 pictrue/8.png" alt="" width="375" height="125" >
    </div>
    <figcaption><i>图 8 演示了一个简单的谓词示例，强调在此查询中，由于查询包含一个基于唯一键的等值谓词（id = 123），因此可以轻松选择主键索引来执行查询。数据库系统会自动使用主键索引来加速查询，避免全表扫描</i><figcaption>
</figure>

<figure>
    <div style="text-align: center;">
        <img src="./14 pictrue/9.png" alt="" width="375" height="125" >
    </div>
    <figcaption><i>图 9 演示了复杂谓词的示例，说明类似范围查询或多个条件的组合查询，比单一等值查询更难估计，因为需要综合多个条件的选择基数。例如，查询中的 age = 30 和 status = 'Lit' 之间可能存在关联，因此不能简单地相乘选择性，需要通过更加复杂的计算方式来估计符合条件的记录数量。</i><figcaption>
</figure>



### 直方图
由于实际数据往往偏态，DBMS使用直方图来减少存储开销。最常见的有等宽直方图和等深直方图，后者调整每个桶的范围以确保每个桶中的数据数量大致相等。

<figure>
    <div style="text-align: center;">
        <img src="./14 pictrue/10.png" alt="" width="600" height="325" >
    </div>
    <figcaption><i>图10展示了一个关于否定查询选择性的示例，解释了如何计算否定查询的选择性。</i><figcaption>
</figure>

<figure>
    <div style="text-align: center;">
        <img src="./14 pictrue/11.png" alt="" width="600" height="375" >
    </div>
    
</figure>


### 采样
DBMS可以通过对表的子集进行采样来估算选择性，而不是处理整个表。当表中的数据变更超过某个阈值（如10%），DBMS会更新采样数据。简单来说就是只用一小部分的值来计算。

<figure>
    <div style="text-align: center;">
        <img src="./14 pictrue/12.png" alt="" width="600" height="305" >
    </div>
    
</figure>

### 计划枚举
在基于规则的重写之后，DBMS会枚举不同的计划并估算它们的成本，最后选择最佳的计划。

### 单表查询计划
对于单表查询计划，最主要的挑战是选择最佳的访问方法（如顺序扫描、二分查找、索引扫描等）。大多数现代DBMS使用启发式方法来选择访问方法，而不是复杂的成本模型。

### 多表查询计划
对于多表查询计划，随着连接数量的增加，可能的计划数量急剧增加。因此，必须限制搜索空间，以在合理的时间内找到最佳计划。搜索方式主要有两种：

- **自底向上**：从空开始，逐步构建查询计划。
    - 示例：IBM System R、DB2、MySQL、Postgres等。

- **自顶向下**：从目标开始，逐步向下搜索找到最佳计划。
   - 示例：MSSQL、Greenplum、CockroachDB等。

### System R的自底向上优化示例
System R使用静态规则进行初步优化，然后通过动态规划确定表的最佳连接顺序。这种方法将查询分解为多个区块，并逐步构建最优的查询计划。

### Volcano的自顶向下优化示例
Volcano采用自顶向下的方式，通过分支定界搜索将逻辑操作符转换为物理操作符，并在搜索过程中记录全局最优计划。