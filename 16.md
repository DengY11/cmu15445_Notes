# CMU15445 16
## 两阶段锁协议(Two-Phase Locking)

### 1. 事务锁（Transaction Locks）
- #### 锁的作用：
  - 锁用于保护数据库对象，确保在多事务并发访问时保证数据一致性。DBMS使用锁来动态地生成可串行化的执行计划。
<img src="./16 pictrue/1.png" alt="" width="600" height="300">
- #### 锁的类型：
  - **共享锁（S-LOCK）**：允许多个事务同时读取同一个对象。如果一个事务持有共享锁，其他事务也可以获取该锁。
  - **排他锁（X-LOCK）**：允许事务修改对象。此锁阻止其他事务获取任何其他类型的锁（共享锁或排他锁）在该对象上。同一时间只能有一个事务持有排他锁(类似于mutex互斥量)。
- #### 锁管理器：
  - DBMS 中的锁管理器决定事务是否可以获取锁，并维护一张内部锁表，记录哪些事务持有哪些锁以及哪些事务在等待获取锁。
- #### 锁与闩的区别：
  - 锁保护数据库的值，防止并发事务之间的冲突，而闩（latch）用于保护DBMS的内部数据结构，防止并发线程之间的冲突。
<img src="./16 pictrue/2.png" alt="" width="600" height="300">

### 2. 两阶段锁协议（Two-Phase Locking，2PL）
- #### 两阶段锁协议：
  - 2PL 是一种**悲观**的并发控制协议，事务在运行时根据需要请求锁，分为两个阶段：
    - **增长阶段（Growing Phase）**：
      - 事务可以向锁管理器请求锁（共享锁 S-LOCK 或排他锁 X-LOCK）。
      - 锁管理器根据当前锁的持有状态，决定是否授予锁。
      -  如果锁可以被授予，事务将获得锁并继续执行。
      - 如果锁被其他事务持有，事务将等待，直到锁被释放。
      - 在这个阶段，事务**不能释放任何锁**。
    - **收缩阶段（Shrinking Phase）**：事务开始释放第一个锁后，就进入收缩阶段。在这个阶段：
      - 事务只能释放它持有的锁，不能再请求新的锁。
      - 事务会依次释放它不再需要的锁，直到事务结束。
      - 事务在收缩阶段释放锁后，其他事务可能获取这些锁以继续执行。
      - 
<img src="./16 pictrue/3.png" alt="" width="600" height="300">

- #### 保证冲突串行化：
  - 2PL 保证了冲突串行化，因为它确保每个事务在操作对象时持有适当的锁，防止冲突操作的交错。
- #### 问题：
  - **级联中止（Cascading Aborts）**：一个事务的中止可能导致其他事务的中止，造成浪费的工作。
  - **死锁**：由于事务相互等待锁，可能会出现死锁。
  - **可串行化限制**：有些本可串行化的执行计划可能由于 2PL 的限制而无法执行。
---
#### 两阶段锁协议（2PL）示例

假设我们有两个事务 \( T1 \) 和 \( T2 \)，它们对两个数据项 \( A \) 和 \( B \) 进行读写操作。

#### 示例事务

- **事务 \( T1 \)**:
  1. 读取 \( A \)
  2. 写入 \( A \)
  3. 写入 \( B \)
  
- **事务 \( T2 \)**:
  1. 读取 \( B \)
  2. 写入 \( B \)

#### 2PL 的执行过程

##### 步骤 1: 开始事务 \( T1 \)

1. \( T1 \) 请求并获得对 \( A \) 的共享锁（S-LOCK），因为它需要读取 \( A \)。
2. \( T1 \) 读取 \( A \) 的值。

   - 当前锁状态：\( T1 \) 对 \( A \) 持有 S-LOCK

##### 步骤 2: 继续事务 \( T1 \)

3. \( T1 \) 升级对 \( A \) 的锁，将 S-LOCK 升级为排他锁（X-LOCK），因为它需要写入 \( A \)。
4. \( T1 \) 写入 \( A \) 的新值。

   - 当前锁状态：\( T1 \) 对 \( A \) 持有 X-LOCK

##### 步骤 3: 启动事务 \( T2 \)

5. \( T2 \) 请求并获得对 \( B \) 的共享锁（S-LOCK），因为它需要读取 \( B \)。
6. \( T2 \) 读取 \( B \) 的值。

   - 当前锁状态：\( T1 \) 对 \( A \) 持有 X-LOCK，\( T2 \) 对 \( B \) 持有 S-LOCK

##### 步骤 4: 继续事务 \( T1 \)

7. \( T1 \) 请求对 \( B \) 的排他锁（X-LOCK），因为它需要写入 \( B \)。
8. 由于 \( T2 \) 持有 \( B \) 的共享锁，\( T1 \) 必须等待 \( T2 \) 释放锁。

   - 当前锁状态：\( T1 \) 对 \( A \) 持有 X-LOCK，\( T2 \) 对 \( B \) 持有 S-LOCK
   - \( T1 \) 等待 \( T2 \) 释放 \( B \) 的锁

##### 步骤 5: 继续事务 \( T2 \)

9. \( T2 \) 升级对 \( B \) 的锁，将 S-LOCK 升级为 X-LOCK，因为它需要写入 \( B \)。
10. \( T2 \) 写入 \( B \) 的新值。
11. \( T2 \) 进入收缩阶段，释放 \( B \) 的 X-LOCK。

   - 当前锁状态：\( T1 \) 对 \( A \) 持有 X-LOCK
   - \( T1 \) 现在可以获得对 \( B \) 的 X-LOCK

##### 步骤 6: 继续事务 \( T1 \)

12. \( T1 \) 获得对 \( B \) 的排他锁（X-LOCK）。
13. \( T1 \) 写入 \( B \) 的新值。
14. \( T1 \) 进入收缩阶段，释放 \( A \) 和 \( B \) 的 X-LOCK。

#### 执行总结

- 在这个执行过程中，事务 \( T1 \) 和 \( T2 \) 根据两阶段锁协议进行了操作：
  - \( T1 \) 在执行过程中逐步获得锁，在完成所有写操作后进入收缩阶段并释放锁。
  - \( T2 \) 同样在执行过程中请求并释放锁。
  
- **增长阶段**：每个事务在它开始执行到它首次释放锁之间的时间段内处于增长阶段。它们可以获得新的锁，但不能释放锁。
- **收缩阶段**：每个事务在首次释放锁后进入收缩阶段。在此阶段，它们只能释放锁，不能再获得新的锁。

#### 2PL 保证的正确性

- **防止冲突**：在 \( T2 \) 对 \( B \) 进行写操作前，\( T1 \) 由于无法获取 \( B \) 的锁而等待。这防止了 \( T1 \) 和 \( T2 \) 对 \( B \) 的交错操作，保证了串行化。
- **正确性**：通过两阶段锁协议，确保任何并发执行的结果都等价于某个顺序执行的结果（冲突串行化）。

#### 注意事项

- **死锁**：在这个例子中没有出现死锁，但在更复杂的事务中，如果两个事务互相等待对方持有的锁，则可能发生死锁。
- **级联中止**：如果 \( T2 \) 在写入 \( B \) 之后中止，那么 \( T1 \) 需要回滚已经读取 \( B \) 的事务。

---
### 3. 强严格两阶段锁协议（Strong Strict 2PL）
- **强严格 2PL**：事务只在提交时释放所有锁。这样做的好处是避免了级联中止，因为只有在事务提交后其他事务才能读取或修改它写入的数据。
- **并发性限制**：由于事务在整个执行过程中都持有锁，因此这种方式更为谨慎，限制了并发性。
- 
<img src="./16 pictrue/4.png" alt="" width="600" height="300">

### 4. 死锁处理（Deadlock Handling）
- **死锁**：事务之间相互等待彼此释放锁，形成了等待循环。
- **处理方法：**
  - **1.死锁检测**：使用**等待图**(Waits-for Graph)来检测死锁。在该图中，节点表示事务，边表示事务等待其他事务释放锁。周期性地**检测等待图中的环来识别死锁**，然后选择一个事务作为“牺牲品”来中止，以打破死锁。
  - **2.死锁预防**：通过优先级策略来避免死锁的产生。例如：
    - **Wait-Die**：如果请求锁的事务优先级高于持有锁的事务，则请求的事务等待；否则它中止。
    - **Wound-Wait**：如果请求锁的事务优先级高于持有锁的事务，则持有锁的事务中止；否则请求的事务等待。

<img src="./16 pictrue/5.png" alt="" width="600" height="300">

---

### Wait-Die 和 Wound-Wait 示例

假设我们有两个事务 \( T1 \) 和 \( T2 \)，它们各自尝试获取锁，同时有时间戳分配来确定事务的优先级：

- **\( T1 \)**：时间戳较小（假设为 1），优先级较高（老事务）。
- **\( T2 \)**：时间戳较大（假设为 2），优先级较低（新事务）。


## Wait-Die 策略


1. **\( T1 \) 尝试获取 \( A \) 的锁**：
   - \( T1 \) 获得 \( A \) 的排他锁（X-LOCK）。
   - 锁状态：\( T1 \) 持有 \( A \) 的 X-LOCK。

2. **\( T2 \) 尝试获取 \( B \) 的锁**：
   - \( T2 \) 获得 \( B \) 的排他锁（X-LOCK）。
   - 锁状态：\( T1 \) 持有 \( A \) 的 X-LOCK，\( T2 \) 持有 \( B \) 的 X-LOCK。

3. **\( T1 \) 尝试获取 \( B \) 的锁**：
   - \( T1 \) 现在需要 \( B \) 的锁，但 \( B \) 被 \( T2 \) 持有。
   - \( T1 \) 的优先级高于 \( T2 \) （因为 \( T1 \) 的时间戳较小）。
   - 根据 **Wait-Die** 策略，优先级高的事务可以等待，因此 \( T1 \) 等待 \( T2 \) 释放 \( B \) 的锁。

4. **\( T2 \) 尝试获取 \( A \) 的锁**：
   - \( T2 \) 现在需要 \( A \) 的锁，但 \( A \) 被 \( T1 \) 持有。
   - \( T2 \) 的优先级低于 \( T1 \) （因为 \( T2 \) 的时间戳较大）。
   - 根据 **Wait-Die** 策略，优先级低的事务不能等待，需要中止，因此 \( T2 \) 中止（dies）。

#### 结果
- \( T1 \) 等待 \( T2 \) 释放 \( B \) 的锁。
- \( T2 \) 中止并释放了 \( B \) 的锁。
- \( T1 \) 获得 \( B \) 的锁，继续执行。

## Wound-Wait 策略



1. **\( T1 \) 尝试获取 \( A \) 的锁**：
   - \( T1 \) 获得 \( A \) 的排他锁（X-LOCK）。
   - 锁状态：\( T1 \) 持有 \( A \) 的 X-LOCK。

2. **\( T2 \) 尝试获取 \( B \) 的锁**：
   - \( T2 \) 获得 \( B \) 的排他锁（X-LOCK）。
   - 锁状态：\( T1 \) 持有 \( A \) 的 X-LOCK，\( T2 \) 持有 \( B \) 的 X-LOCK。

3. **\( T1 \) 尝试获取 \( B \) 的锁**：
   - \( T1 \) 现在需要 \( B \) 的锁，但 \( B \) 被 \( T2 \) 持有。
   - \( T1 \) 的优先级高于 \( T2 \) （因为 \( T1 \) 的时间戳较小）。
   - 根据 **Wound-Wait** 策略，优先级高的事务将中止（伤害）优先级低的事务，因此 \( T2 \) 中止并释放锁。
   - \( T1 \) 获得 \( B \) 的锁。

4. **\( T2 \) 尝试获取 \( A \) 的锁**：
   - \( T2 \) 重新启动，并尝试获取 \( A \) 的锁，但此时 \( T1 \) 仍持有 \( A \) 的锁。
   - \( T2 \) 的优先级低于 \( T1 \) （因为 \( T2 \) 的时间戳较大）。
   - 根据 **Wound-Wait** 策略，优先级低的事务将等待，因此 \( T2 \) 等待。

### 结果
- \( T1 \) 伤害了 \( T2 \)，中止了 \( T2 \)，并获取了 \( B \) 的锁。
- \( T2 \) 中止并重新启动，然后等待 \( T1 \) 释放 \( A \) 的锁。

---

### 5. 锁粒度（Lock Granularities）
- **锁粒度**：指的是锁所作用的对象大小。不同粒度的锁可以影响系统的性能和并发性。
  - **细粒度锁**：如元组级锁，可以增加并发性，但需要更多的锁管理开销。
  - **粗粒度锁**：如表级锁，可以减少锁管理开销，但会降低并发性。
- **锁层次结构**：DBMS 使用锁层次结构（Lock Hierarchy）来平衡锁的粒度。
  - 1.数据库级
  - 2.表级
  - 3.页级
  - 4.元组级
  - 5.属性级

<img src="./16 pictrue/6.png" alt="" width="600" height="300">

- **意向锁（Intention Locks）**：用于表明在更低层次上的锁定意图，以协调细粒度和粗粒度锁的使用。
  - **意向共享锁（IS）**：
    - 表示在更低级别有共享锁定。当一个事务想要读取数据时，通常会在具体的行或页上加共享锁（S 锁），以保证读取的数据在读取期间不被修改。为了表示这个意图，事务首先会在更高级别的资源上加上 IS 锁。例如，事务可以在表级别加 IS 锁，然后在具体的行上加 S 锁。
    - IS 锁的目的 是为了在并发场景下提高锁的管理效率，避免对高层资源（如整个表）加 S 锁，导致其他事务无法对不同的行或页面进行操作。通过 IS 锁，数据库可以知道该事务可能在较低级别的资源（如行）上获取 S 锁，但不会阻止其他事务对不同的行进行修改或锁定。
  - **意向排他锁（IX）**：
    - IX 锁表示当前事务有意图在某一资源（如表、页或行）上获取排他锁（X 锁）。IX 锁本身并不阻止其他事务读取数据，但表明该事务接下来可能会对数据进行修改操作。IX 锁可以加在表或页面级别，而不直接锁定具体的行。IX 锁的作用是：当事务获取了某个级别的 IX 锁时，其他事务依然可以在不同的行上加 S 锁（共享锁）进行读取，但不能加 X 锁（排他锁），防止冲突。
    - 假设事务 A 想要修改表中某一行的数据，那么事务 A 可能会首先在表级别加上 IX 锁，然后在要修改的具体行上加上排他锁（X 锁）。此时，其他事务依然可以在表的其他行上进行读取操作，但不能修改相同的行。
  - **共享 + 意向排他锁（SIX）**：
    - SIX 锁是共享锁（S 锁）和意向排他锁（IX 锁）的结合。它表示当前事务在一个资源（如表）上有读取权限，并且有意图在该资源的部分（如行）上获取排他锁进行写操作。
    - SIX 锁允许事务读取整个资源，但表示该事务打算在某些行或页面上获取排他锁进行修改。因此，SIX 锁与纯 S 锁不同，虽然它允许读取，**但它会阻止其他事务对整个资源获取任何类型的排他锁（包括IX锁或X锁）**，因为同一事务中可能会对资源的一部分进行修改。
    - 假设事务 B 在一个表上获取了 SIX 锁，这意味着事务 B 可以读取该表的所有数据，并且可能在其中某些行上获取 X 锁进行修改。其他事务在这个时候可以读取数据（获取 S 锁），但不能在表上获取 IX 锁或 X 锁，因为事务 B 可能会对表的某些部分进行修改。

### 总结
这些概念展示了数据库管理系统如何使用锁和两阶段锁协议来确保并发事务的正确性。锁的粒度、锁协议的选择以及死锁处理策略都对系统的性能和并发性有着重要影响。通过合理的锁机制和并发控制协议，DBMS 能够在保证数据一致性的同时，最大限度地提高系统的并发性能。